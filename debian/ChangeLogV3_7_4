Change Log for Release 3.7.4

GNU Radio release 3.7.4 is available for download:

http://gnuradio.org/releases/gnuradio/gnuradio-3.7.4.tar.gz

MD5 sum:

94e7115ad7b46b5bc9e0b336cf74d8ba gnuradio-3.7.4.tar.gz

This release incorporates a large number of new features and bug fixes, and represents a longer than usual development time between stable releases.
Contributors:

A. Maitland Bottoms <bottoms@debian.org>
Andy Walls <andy@silverblocksystems.net>
Balint Seeber <balint@ettus.com>
Ben Reynwar <ben@reynwar.net>
Bolin Hsu <bolin.hsu@gmail.com>
Camilo Solano <solano@ti.rwth-aachen.de>
Clayton Smith <argilo@gmail.com>
Dimitri Stolnikov <horiz0n@gmx.net>
Jared Boone <jboone@earfeast.com>
Jiří Pinkava <j-pi@seznam.cz>
Johannes Schmitz <schmitz@ti.rwth-aachen.de>
Johnathan Corgan <johnathan@corganlabs.com>
Kevin Reid <kpreid@switchb.org>
Marcus Müller <marcus@hostalia.de>
Mark Cottrell <mark.cottrell@taitradio.com>
Martin Braun <martin.braun@ettus.com>
Michael Dickens <mlk@alum.mit.edu>
Nathan West <nathan.west@okstate.edu>
Nicholas Corgan <nick.corgan@ettus.com>
Nicholas McCarthy <namccart@gmail.com>
Nick Foster <bistromath@gmail.com>
Peter A. Bigot <pab@pabigot.com>
Philippe Gauthier <philippe.gauthier@deuxpi.ca>
Sean Nowlan <sean.nowlan@gtri.gatech.edu>
Sebastian Koslowski <koslowski@kit.edu>
Seth Hitefield <sdhitefield@gmail.com>
Sylvain Munaut <tnt@246tNt.com>
Tim Kuester <tpkuester@gmail.com>
Tim O'Shea <tim.oshea753@gmail.com>
Tom Rondeau <tom@trondeau.com>

Thanks for your effort and contributions.

Data Flow/Control Flow in GNU Radio
=================================================

For many years, GNU Radio's main architectural feature has revolved
around a high-speed data-flow design for processing large amounts of
streaming data between signal processing blocks.  This has made it
well suited for real-time PHY implementations and for continuously
received and transmitted over-the-air applications.

In these radio implementations, "control plane" logic has been
primarily implemented outside GNU Radio, using general purpose
programming constructs and communicating with and manipulating the GNU
Radio portion of the applications through function calls.

Beginning in the 3.6 API series and even more so now in 3.7, we've
been adding the internal features to allow more of a radio
application's control logic to be also implemented directly in GNU
Radio:

* Stream tags allow attaching tightly-coupled metadata to data streams
  to communicate with downstream blocks

* Asynchronous inter-block messaging allows event-based control within
  a flowgraph and into and out of a flowgraph.

* PDU-based data flow and tagged stream blocks simplify working with
  packet-oriented data.

* Messaging only blocks ("mblocks") are ideal for implementing
  event-driven state machines.

Release 3.7.4 has a large set of updates in this area, including:

* Async-messaging based parameter updates for some blocks (instead of
  function calls)

* Stream-tag based triggers for some data display blocks

* Burst mode support for discontinuous transmission with gr-uhd

* Stream tag and async messaging control interfaces for gr-uhd

* Several new PDU-based versions of streaming blocks

Expect to see more overhauling of existing blocks in the DSP library
to take advantage of these capabilities, as well as incorporating them
as needed into newly developed signal processing blocks.


Merging of FEC API into gr-fec
==============================

The new FEC API is a brand new concept in GNU Radio to help facilitate
the use of forward error correction techniques in modulators and
demodulators. Due to the widely varying styles of interfaces and data
formats required by different FEC techniques as well as handling of
packetizing and other transmit/receive issues, we have defined the FEC
API to describe the different formatting techniques required for each
type of encoder or decoder.

We therefore design an FEC API encoder or decoder as an object that is
/not/ a GNU Radio block. We then create a proper deployment that is a
GNU Radio block and fits into the flowgraph. The deployment handles
the connections to the flowgraph and the appropriate way to call the
encoder or decoder object to process the data. We expect different
deployments will be needed for different purposes, but to help with a
great number of possible situations, we have created deployments to
handle the basic cases of dealing with continuous streaming data,
tagged-stream data, and asynchronous data via message passing of PDUs.

Some more information on the FEC API can be found here:

http://www.trondeau.com/home/2014/6/24/update-and-374.html

And the API and the deployment concept and structure are documented in
the GNU Radio manual:

http://gnuradio.org/doc/doxygen/page_fec.html


Addition of new ØMQ wrapper blocks: gr-zeromq
=============================================

ZeroMQ is an intelligent transport layer for applications built as a
thin message-passing wrapper around TCP, IPC, and in-memory
transports.  A good introduction to its capabilities is found here:

http://zguide.zeromq.org/page:all

Quoting:

"It gives you sockets that carry atomic messages across various
transports like in-process, inter-process, TCP, and multicast. You can
connect sockets N-to-N with patterns like fan-out, pub-sub, task
distribution, and request-reply."

Release 3.7.4 incorporates new flowgraph sources and sinks which allow
attaching ZeroMQ sockets to GNU Radio streaming ports.

This is a work-in-progress.  Right now, blocks exist for the
PUSH/PULL, PUB/SUB, and REQ/REP messaging patterns described in the
above guide, connecting to streaming data ports.  This facilitates
distributing signal processing tasks among multiple applications in a
more robust way than can be accomplished our existing TCP and UDP
sinks:

* ZeroMQ sockets are an an abstraction above several transport types,
  allowing the developer to change simply by specifying a different
  endpoint identifier.

* ZeroMQ network transports are self-connecting and self-healing,
  allowing endpoint start up in arbitrary order and recovery from
  network outages

* More complicated data distribution networks can be set up other than
  single point to single point

* ZeroMQ is message based, guaranteeing all-at-once delivery to the
  remote endpoint of data, simplifying reception logic

* Future versions of ZeroMQ support will include the use of
  authenticated and encrypted connections.

During the 3.7.5 development process, we expect to incorporate these
interfaces into async messaging blocks and to tunnel stream tags through
the existing blocks.

Some experimental work is also going on with these blocks that would
allow a remotely executing GUI display to interact with a GNU Radio
flowgraph, with display data and control flow being handled by ZeroMQ.
This would result in a GUI that would appear identical whether the
actual signal processing was occurring locally or not.


Improvements to the GNU Radio Companion
=======================================

GRC continues to see a lot of usability improvements coming of of the
GRC Working Group:

* The block search path is now output on startup, making it easier to
  debug "missing block" problems with out-of-tree modules

* The block properties dialog box now tabbed, moving advanced features
  and documentation into their own areas and simplifying the main
  parameter area

* When opening flowgraphs with blocks that are missing, dummy blocks
  are displayed, with their connections intact

* It is possible now to toggle on and off the display of disabled
  blocks

* The validation of block parameters is delayed until tabbing out of a
  block field, eliminating the character-by-character screen updates
  and sluggishness

* A new tools menu has been added, with the first entry the ability to
  invoke the GNU Radio Filter Designer application

* The log window can now be scrolled and cleared

* Individual blocks can now have custom thread names assigned via
  their parameter blocks (see gr-runtime discussion)


Improvements to gr-qtgui
========================

We are continuing to improve the support and feature set of the QTGUI
plotting blocks, which will become a major focus in 3.7.5. For this
release, we have fixed a few issues.

While the blocks all have a "name" field, this field didn't actually
do anything graphically. Now, we use this to add a title to the
graph. If "name" is blank, which is the new default, then there will
be no title and no vertical space taken up by a title. Setting a name
will then show this as a title on the top of the graph.

We have added an input and output message port to the QTGUI sink,
frequency sink, and waterfall sink. The input message port 'freq'
takes a message as a command pair, pmt::cons(pmt::intern("freq"),
pmt::from_double(frequency)), and uses this to adjust the center
frequency of the plot. The output message port is activated whenever
the plot is double-clicked by the user and produces the same command
pair message format as the input where the frequency is whatever
frequency the mouse pointer was on when clicked.

The use of the PMT pair command format is done for compatibility with
the command format used in the gr-uhd blocks. Further, we can
loop-back the output message port to the input message port to enable
a "click-to-tune" feature where double-clicking on the graph will
recenter the graph at that frequency.

The freq_xlating_fir_filter was outfitted with an input message port
to work with this concept so that we can tune a receiver by
double-clicking on the frequency or waterfall plot.


Modifications to the GNU Radio runtime
======================================

Each flowgraph block thread can now be given a custom name, either in
code or via GRC.  This makes debugging via stack traces in GDB or
through process display tools like htop much easier. By default, the
thread name is the block name and instance number.

Several improvements were made to the pmt library for dealing with
vectors of data and dictionaries.


GNU Radio Build System
======================

A new build option, ENABLE_STATIC_LIBS, add building static libraries
to the existing build.  This is intended to facilitate development on
platforms that require static linking.


VOLK Library Updates
====================

* Compile time support for disabling ORC (cmake option -DENABLE_ORC)

* Add support for forcing generic proto-kernels to run (through
  environment variable VOLK_GENERIC)

* VOLK QA buffers changed to use volk_malloc

* Add a binary slicer kernel with AVX and SSE implementations

* Add a new rate 1/2, K=7 convolutional decoder kernel derived from
  Spiral


Important Bug Fixes and Additions
=================================

* Fixed shutdown in message passing apps

* Fixed PortAudio detection during configuration

* Fixed QWT detection during configuration

* Fixed gr::analog::agc3 volk kernel alignment

* Fixed/improved support of audio on OSX

* Improved performance on network-based sources and sinks

* Fixed pfb_arb_resampler tag propagation

* Fixed segfault in fast_atan2f

* Updated codec2 support to latest standard and support all rates

* New HDLC codec blocks in gr::digital
