From e0561eaf4bdf8ad8467aa7765d7f601e9b792ddc Mon Sep 17 00:00:00 2001
From: Tom Rondeau <tom@trondeau.com>
Date: Wed, 4 Sep 2013 15:45:01 -0400
Subject: [PATCH 06/40] digital: Added a new constellation_soft_decoder block
 that produces soft decisions as floats instead of
 hard decisions.

Added documentation for how to use the new soft decision tools.
---
 gr-digital/doc/digital.dox                         |  457 ++++++++++++++++++++
 gr-digital/grc/digital_block_tree.xml              |    3 +
 gr-digital/grc/digital_constellation.xml           |   71 +++
 gr-digital/grc/digital_constellation_rect.xml      |   87 ++++
 .../grc/digital_constellation_soft_decoder_cf.xml  |   25 ++
 gr-digital/include/gnuradio/digital/CMakeLists.txt |    3 +-
 .../digital/constellation_soft_decoder_cf.h        |   62 +++
 gr-digital/lib/CMakeLists.txt                      |    1 +
 .../lib/constellation_soft_decoder_cf_impl.cc      |   78 ++++
 .../lib/constellation_soft_decoder_cf_impl.h       |   50 +++
 .../digital/qa_constellation_soft_decoder_cf.py    |  112 +++++
 gr-digital/swig/digital_swig.i                     |    3 +
 grc/blocks/variable_constellation.xml              |   51 ---
 grc/blocks/variable_constellation_rect.xml         |   69 ---
 14 files changed, 951 insertions(+), 121 deletions(-)
 create mode 100644 gr-digital/grc/digital_constellation.xml
 create mode 100644 gr-digital/grc/digital_constellation_rect.xml
 create mode 100644 gr-digital/grc/digital_constellation_soft_decoder_cf.xml
 create mode 100644 gr-digital/include/gnuradio/digital/constellation_soft_decoder_cf.h
 create mode 100644 gr-digital/lib/constellation_soft_decoder_cf_impl.cc
 create mode 100644 gr-digital/lib/constellation_soft_decoder_cf_impl.h
 create mode 100644 gr-digital/python/digital/qa_constellation_soft_decoder_cf.py
 delete mode 100644 grc/blocks/variable_constellation.xml
 delete mode 100644 grc/blocks/variable_constellation_rect.xml

diff --git a/gr-digital/doc/digital.dox b/gr-digital/doc/digital.dox
index 2809c6a..48feda3 100644
--- a/gr-digital/doc/digital.dox
+++ b/gr-digital/doc/digital.dox
@@ -20,4 +20,461 @@ by using:
     help(digital)
 \endcode
 
+\section digital_constellations Constellation Objects
+
+GNU Radio supports the creation and use of Constellation objects for
+many of its digital communications needs. We define these
+constellations with a set of constellation points in complex space and
+the symbol mappings to those points. For a constellation that has 4
+symbols, it then has log2(4) = 2 bits/symbol. We define this
+constellation with:
+
+<pre>
+    constel_points = [c0, c1, c2, c3]
+    symbols = [s0, s1, s2, s3]
+</pre>
+
+In this case: \f$c_i \in C\f$ and \f$s_i \in [00, 01, 10,
+11]\f$. Also, the mapping is a 1-to-1 for the items in both lists, so
+the symbol \f$s_0\f$ is positioned in complex space at the point
+\f$c_0\f$.
+
+In the code itself, the symbols are referred to as the
+'pre_diff_code' since this is the mapping before the application of
+differential modulation, if used.
+
+The constellation object classes are defined in constellation.h. There
+is a hierarchy of classes for different purposes and which represent
+special classes of constellations. The all derive from the virtual
+class gr::digital::constellation. All constellations we will make are
+based on classes derived from this base:
+
+<pre>
+gr::digital::constellation
+    --> gr::digital::constellation_calcdist
+    --> gr::digital::constellation_sector
+        --> gr::digital::constellation_rect
+            --> gr::digital::constellation_expl_rect
+        --> gr::digital::constellation_psk
+    --> gr::digital::constellation_bpsk
+    --> gr::digital::constellation_qpsk
+    --> gr::digital::constellation_dqpsk
+    --> gr::digital::constellation_8psk
+</pre>
+
+Each constellation class has a set of attributes and functions useful
+for manipulating the constellations and for converting symbols to and
+from complex points. One of the more important functions is the
+gr::digital::constellation::decision_maker function that takes in a
+sample in complex space and returns the symbol that it maps to. How
+this calculation is performed generally distinguishes the
+constellation classes from each other.
+
+The gr::digital::constellation_calcdist is the most generic
+constellation class we can create. This takes in the constellation
+points, symbol mapping, a rotational symmetry, and the number of
+dimensions. The decision_maker function takes in a complex sample x
+and calculates the Euclidean distance between x and each point in the
+constellation map of the object. The constellation point that has the
+minimum Euclidean distance to x is selected as the best match. The
+decision_maker will then return the symbol value that matches to this
+selected constellation point.
+
+We then have a concept of a constellation with a well-defined concept
+of sectors in the gr::digital::constellation_sector. This is farther
+refined if we know that the constellation is rectangular and can use
+the gr::digital::constellation_rect class. These classes have an
+overloaded decision_maker function that is specific to how the sectors
+are defined in the constructor. Essentially, the decision making math
+for this class is less costly than calculating the Euclidean distance
+for each point in the space. So if we can sectorize our constellation,
+using this class will be computationally cheaper.
+
+Finally, we have a set of pre-defined, hard-coded constellations for
+BPSK (gr::digital::constellation_bpsk), QPSK
+(gr::digital::constellation_qpsk), DQPSK
+(gr::digital::constellation_dqpsk), and 8PSK
+(gr::digital::constellation_8psk). These derive directly from
+gr::digital::constellation and specifically overload the decision_maker
+function. We have very simple metrics for calculating decisions for
+each of these constellations. For BPSK, we simply slice on the real
+axis. Samples are based solely on whether the real part of the complex
+symbol x is greater than or less than 0. Similar, simple, decision
+makers are defined for the others.
+
+Note that these specific constellations for the PSK modulations are
+defined for only one mapping of the constellation points to the
+symbols. Each is Gray coded, but for a specific Gray coding that is
+hard-coded into the class.
+
+
+\subsection grc_constellations Constellation Objects in GRC
+
+GRC provides two constellation representations that we can use to more
+easily define and interact with constellation objects. These are
+located in the 'Modulators' category as 'Constellation Object' and
+'Constellation Rect. Object'. These allow us to easily specify the
+constellation points, symbol list, and other properties of the
+constellation objects. They return the base() of the object, so the
+variable's ID can be used directly with blocks that accept
+constellation objects.
+
+These constellation blocks also allow us to specify the soft decision
+LUT if using the constellation object for soft decision outputs. The
+input can either be 'None' (default), a list of the soft bits that
+were generated externally or by another function, or 'auto' where the
+block will automatically calculate the soft decisions based on the
+constellation points and symbol map.
+
+
+\section digital_python_helpers Python Constellation Helper Functions
+
+A series of helper functions are defined in Python to create
+different, common constellations. There are various functions that
+have various levels of complexity in their definitions.
+
+\subsection digital_python_helpers_psk PSK Python Helpers
+
+There are two modules imported directly into gnuradio.digital. The
+first is gr-digital/python/digital/psk.py and the second is
+gr-digital/python/digital/psk_constellations.py. The
+gr-digital/python/digital/psk.py module defines the following
+constellations:
+
+<pre>
+    psk_constellation(m, mod_code, differential)
+</pre>
+
+This function defines a PSK modulation of order 'm' (that is, there
+are m number of constellation points / symbols). The 'mod_code' is
+either mod_codes.GRAY_CODE or mode_codes.NO_CODE to set the symbol
+mapping up as either Gray coded or not. The 'differential' argument is
+either True to use differential coding or False for non-differential
+coding.
+
+This function creates and returns a constellation object that can then
+be used by any block that takes a constellation
+(gr::digital::constellation_decoder_cb,
+gr::digital::constellation_receiver_cb,
+gr::digital::constellation_soft_decoder_cf, or
+gr::digital::lms_dd_equalizer_cc).
+
+The gr-digital/python/digital/psk.py module also holds functions
+similar to digital.psk_constellation but that create a full modulator
+and demodulator chain derived from digital.generic_mod_demod.
+
+<pre>
+    psk_mod(constellation_points, mod_code, differential, *args, **kwargs)
+    psk_demod(constellation_points, mod_code, differential, *args, **kwargs)
+</pre>
+
+The args and kwargs are parameters of the generic_mod or generic_demod
+passed directly to them. See \ref digital_generic_mod_demod for
+details of this interface.
+
+There is another Python file full of helper functions to create
+different constellations. This is found in the
+gr-digital/python/digital/psk_constellation.py file. This file
+provides functions that build the vectors of constellation points and
+symbol mappings that can be used to create a constellation
+object. These are particularly helpful when using the Constellation
+Obj. and Constellation Rect. GUI elements in GRC.
+
+The gr-digital/python/digital/psk_constellation.py file has extensive
+documentation that describes the naming scheme used for the different
+constellations that will not be repeated here. The main thing to
+understand is that these functions define constellations of the same
+order with different Gray code mappings. The function names are:
+
+<pre>
+    (const_points, symbol_map) = psk_M_0xk_<permutation>()
+</pre>
+
+Where M is the order of the modulation (2 for BPSK, 4 for QPSK,
+etc.), and k and \<permutation\> define a particular encoding for the
+Gray code mapping used. The documentation in the file explains how
+these two concepts define the Gray code mapping.
+
+These functions are also simply named "psk_M_n" when n is an integer
+from 0 to N-1 for however many mappings are defined for that
+modulation. Not all modulations are fully defined, and the value
+for n has no other meaning except as a counter.
+
+The functions return a tuple of lists. The first list in the tuple is
+the list of complex constellation points and the second list contains
+the symbols mapped to those points. These lists can then be passed to
+a constellation class directly to create a constellation of any Gray
+code mapping needed.
+
+While not all Gray code mappings of the modulations are defined, there
+is a generator function to automatically build any rotation of a basis
+constellation:
+
+<pre>
+    (const_points, symbol_map) = \
+        constellation_map_generator(basis_cpoints, basis_symbols, k, pi)
+</pre>
+
+We provide a basis constellation map and symbol map as the fundamental
+rotation of the constellation points. This function uses the k and pi
+inputs (see the discussion in psk_constellation.py for what these
+mean) to return a new rotation of the constellation's symbols. If the
+basis symbols are Gray coded than the output symbols will also be Gray
+coded. Note that this algorithm specifically depends on the
+constellation in complex space to be square to preserve the Gray code
+property.
+
+
+\subsection digital_python_helpers_qam QAM Python Helpers
+
+Similar to defining PSK modulations, GNU Radio also has helpers for
+some QAM modulations, found in gr-digital/python/digital/qam.py and
+gr-digital/python/digital/qam_constellations.py. Similar functions to
+what has been described for PSK exist here:
+
+<pre>
+    qam_constellation(constellation_points, differential, mod_code,
+                      large_ampls_to_corners)
+    qam_mod(constellation_points, differential, mod_code, *args, **kwargs)
+    qam_demod(constellation_points, differential, mod_code,
+              large_ampls_to_corner, *args, **kwargs)
+</pre>
+
+The parameters to these functions is the same as for the PSK
+equivalents. The new argument 'large_ampls_to_corner' is defined in
+the documentation as:
+
+<pre>
+    large_ampls_to_corners:  If this is set to True then when the
+        constellation is making decisions, points that are far outside
+        the constellation are mapped to the closest corner rather than
+        the closet constellation point.  This can help with phase
+        locking.
+</pre>
+
+Similarly, gr-digital/python/digital/qam_constellations.py defines a of
+QAM constellation functions that return a tuple containing the
+constellation points and the symbol mappings. The naming scheme is
+defined in depth in the module itself and is similar to the equivalent
+set of PSK functions.
+
+Currently, only a subset of 16QAM symbol mappings are defined, but we
+can use of the constellation_map_generator function described in the
+previous section to define more mapping rotations for and square QAM
+modulation.
+
+
+\section digital_generic_mod_demod The Generic Modulator/Demodulator
+Hierarchical Blocks
+
+Since digital modulation and demodulation are complex functions, the
+different parts can be done by different existing GNU Radio blocks. We
+have combined these into a generic modulator and generic demodulator
+hierarchical blocks to make access and use much easier. This file can
+be found as gr-digital/python/digital/generic_mod_demod.py.
+
+\subsection digital_generic_mod Generic Modulator
+
+The modulator constructor looks like:
+
+<pre>
+    digital.generic_mod(constellation, differential, samples_per_symbol,
+                        pre_diff_code, excess_bw, verbose, log)
+</pre>
+
+The 'constellation' arg is a constellation object as defined above in
+\ref digital_constellations and can represent any constellation
+mapping. The 'differential' arg is a bool to turn differential coding
+on/off. The block also performs pulse shaping and interpolates the
+pulse-shaped filter to some number of 'samples_per_symbol'. The pulse
+shaping is a root raised cosine filter defined by the excess
+bandwidth (or alpha) parameter called 'excess_bw.'
+
+We can also turn on a verbose mode to output information to the
+user. The 'log' parameter toggles logging data on/off. When logging is
+turned on, it stores every stage of the modulation to a different file
+so that each stage can be independently analyzed.
+
+
+\subsection digital_generic_demod Generic Demodulator
+
+The demodulator looks like:
+
+<pre>
+    digital.generic_demod(constellation, differential, samples_per_symbol,
+                          pre_diff_code, excess_bw, freq_bw, timing_bw,
+                          phase_bw, verbose, log)
+</pre>
+
+The additional parameters to the demodulator are the loop bandwidths
+for the different signal recovery loops used internally. There are
+separate loops for frequency acquisition, timing acquisition, and fine
+frequency / phase acquisition, controlled in tern by each of the
+three 'X_bw' arguments. Otherwise, the arguments are the same as the
+modulator.
+
+
+\subsection digital_generic_guts Guts of the Modulator and Demodulator
+
+The generic modulator looks like the following:
+
+<pre>
+    blocks.packed_to_unpacked_bb: takes in packed bytes
+    digital.map_bb: maps baseband symbols to the pre-differential encoding
+    digital.diff_encoder_bb: differentially encode symbols
+    digital.chunks_to_symbols_bc: convert symbols to complex samples
+    filter.pfb_arb_resampler_ccf: perform upsampling to samps/symbol and pulse shape
+</pre>
+
+The mapping and chunks-to-symbols stages are done using the
+information provided by the constellation object.
+
+Note that the modulator takes in packed bytes, which means that all 8
+bits per byte are used and unpacked into k bits per symbol.
+
+The generic demodulator looks like the following:
+
+<pre>
+    digital.fll_band_edge_cc: Performs coarse frequency correction
+    digital.pfb_clock_sync_ccf: Matched filtering and timing recovery
+    digital.constellation_receiver_cb: Phase tracking and decision making (hard bits)
+    digital.diff_decoder_bb: Differential decoding
+    digital.map_bb: Map to pre-differential symbols
+    blocks.unpack_k_bits_bb: Unpack k bits/symbol to a stream of bits
+</pre>
+
+This block outputs unpacked bits, so each output item represents a
+single bit of data. A block like 'pack_k_bits' can be used following
+this to convert the data back into bytes.
+
+
+\section digital_softbits Support for Soft Decisions
+
+To support soft decisions of the receivers instead of the current hard
+decisions, the constellation objects also accept a soft decision
+look-up table (LUT) or can be told to generate a LUT based on the
+constellation points and symbol map.
+
+All constellation objects can accept a new LUT using the
+gr::digital::constellation::set_soft_dec_lut function. This function
+takes in a LUT, which is a vector of floating point tuples (in C++ it
+is just a vector\<vector\<float\>\>) and a precision value that
+specifies how accurate the LUT is to a given number of bits.
+
+The constellation objects also have two functions to calculate the
+soft decisions from their constellation and symbol map. The
+gr::digital::constellation::calc_soft_dec takes a complex number (and
+optional noise power) and returns the soft decisions as a list of
+floats. This function is used internally in the
+gr::digital::constellation::gen_soft_dec_lut, which takes in the LUT's
+precision (as a number of bits) and an optional noise power estimate,
+if known. This function calculates the soft decisions itself. These
+functions are very expensive because each constellation point is taken
+into account during the calculation. We provide the
+gr::digital::constellation::set_soft_dec_lut in order to allow users
+to use one of the many known approximations to more quickly generate
+the soft decision LUT.
+
+The gr::digital::constellation::calc_soft_dec function could be used
+instead of drawing directly from a LUT, which is probably only
+important if the noise floor or channel estimates are likely to change
+and we want to account for this in the decisions. The basic
+implementation of the soft decision calculation is the full
+calculation based on the distance between the sample and all points in
+the constellation space. If using this function for real-time
+decisions, a new object should inherit from the
+gr::digital::constellation class (or whichever child class is being
+used) and redefine this function with a faster approximation
+calculation.
+
+Note: If no soft decision LUT is defined but
+gr::digital::constellation::soft_decision_maker is called then the
+full calculation from gr::digital::constellation::calc_soft_dec is
+used by default.
+
+The LUT is a list of tuples, where each index of the list is some
+quantized (to some number of bits of precision) point in the
+constellation space. At each index, there is a tuple of \e k soft
+bit values for a constellation with \e k bits/symbol.
+
+To help with this, the file
+gr-digital/python/digital/soft_dec_lut_gen.py can be used to create
+these tables. The function digital.soft_dec_table_generator(generator,
+precision) function generates a LUT based on some generator function
+and the number of bits of precision required. This file contains
+documentation explaining the system better. Or the
+digital.soft_dec_table(constel, symbols, prec, npwr=1) can be used
+which takes in the constellation map and symbols to do the full raw
+calculation of the softbits as opposed to a generator function.
+
+To further aid the LUT creation, the digital module also defines a
+number of functions that can be used as soft decision generators for
+the soft_dec_table function. These functions are found in
+psk_constellations.py and qam_constellations.py. These files were
+already mentioned as they contain a set of functions that return
+tuples of constellation points and Gray-mapped symbols for different
+modulations. But these files contain a second set of functions
+prefixed by 'sd_' which are soft decision LUT generator functions Each
+LUT generator takes in a complex value and returns the tuple of soft
+decisions for that point in complex space. To aid with this,
+soft_dec_lut_gen.py defines a 'calc_from_table' function that takes in
+a complex sample, the precision of the table, and the LUT itself and
+returns the tuple of soft decisions in the LUT that is closest to the
+given symbol. Each of these functions can be found directly from the
+'digital' Python module.
+
+The LUTs are defined from min to max constellation points in both the
+real and imaginary axes. That means that signals coming in outside of
+these bounds are clipped to 1. So there is no added certainty for
+values beyond these bounds.
+
+The gr::digital::constellation_soft_decoder_cf block takes in a
+constellation object where a soft decision LUT is defined. It takes in
+complex samples and produces a stream of floats of soft decisions. The
+soft decision outputs are not grouped together, it is just a stream of
+floats. So this block acts as an interpolator that takes in 1 complex
+sample and return \e k float for \e k bits per symbol.
+
+
+\subsection soft_dec_api Review of the Soft Decision API/Functions
+
+Files of interest:
+\li psk_constellations.py: PSK constellations and soft decision generators
+\li qam_constellations.py: QAM constellations and soft decision generators
+\li soft_dec_lut_gen.py: Functions to build soft decision LUTs and test them
+\li test_soft_decisions.py: A script that generates a random complex
+sample and calculates the soft decisions using various methods. Plots
+the sample against the full constellation. Requires matplotlib installed.
+
+Functions:
+\li digital.sd_psk_2_*: Returns (constellation, symbol_map) lists for
+different rotations for BPSK.
+\li digital.sd_psk_4_*: Returns (constellation, symbol_map) lists for
+different rotations for QPSK.
+\li digital.sd_qam_16_*: Returns (constellation, symbol_map) lists for
+different rotations for 16QAM.
+\li digital.soft_dec_table_generator: Takes in a generator function
+(like the digital.sd_XXX above) and creates a LUT to a specific precision.
+\li digital.soft_dec_table: Takes in a constellation/symbol map and
+uses digital.calc_soft_dec to generate a LUT to a specific precision.
+\li digital.calc_soft_dec: Takes a complex sample and calculates the
+soft decisions for a given constellation/symbol mapping.
+\li digital.calc_soft_dec_from_table: Given a sample and a LUT,
+returns the soft decisions of the LUT for the nearest point to the
+sample.
+
+C++ Interface:
+\li gr::digital::constellation::gen_soft_dec_lut: uses calc_soft_dec
+to internally generate a soft decision LUT.
+\li gr::digital::constellation::calc_soft_dec: calculates the soft
+decisions for a given sample from the full constellation/symbol map.
+\li gr::digital::constellation::set_soft_dec_lut: Set the soft
+decision LUT from an externally-calculated LUT.
+\li gr::digital::constellation::has_soft_dec_lut: has the LUT been
+set/generated or not.
+\li gr::digital::constellation::soft_decision_maker: Used by
+gr::digital::constellation_soft_decoder to convert samples to soft
+decisions. If a LUT is defined, uses it; else, uses calc_soft_dec.
+
+
 */
diff --git a/gr-digital/grc/digital_block_tree.xml b/gr-digital/grc/digital_block_tree.xml
index d1033e8..4f4618d 100644
--- a/gr-digital/grc/digital_block_tree.xml
+++ b/gr-digital/grc/digital_block_tree.xml
@@ -60,6 +60,8 @@
     <block>digital_qam_mod</block>
     <block>digital_qam_demod</block>
     <block>digital_constellation_receiver_cb</block>
+    <block>variable_constellation</block>
+    <block>variable_constellation_rect</block>
   </cat>
   <cat>
     <name>Packet Operators</name>
@@ -101,6 +103,7 @@
     <block>digital_chunks_to_symbols_xx</block>
     <block>digital_constellation_decoder_cb</block>
     <block>digital_constellation_receiver_cb</block>
+    <block>digital_constellation_soft_decoder_cf</block>
     <block>digital_diff_decoder_bb</block>
     <block>digital_diff_encoder_bb</block>
     <block>digital_diff_phasor_cc</block>
diff --git a/gr-digital/grc/digital_constellation.xml b/gr-digital/grc/digital_constellation.xml
new file mode 100644
index 0000000..82019d0
--- /dev/null
+++ b/gr-digital/grc/digital_constellation.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0"?>
+<!--
+###################################################
+##Options Block:
+## options for window size,
+## and flow graph building.
+###################################################
+ -->
+<block>
+	<name>Constellation Object</name>
+	<key>variable_constellation</key>
+        <category>Modulators</category>
+	<import>from gnuradio import digital</import>
+        <var_make>self.$(id) = $(id) = digital.constellation_calcdist($const_points, $sym_map, $rot_sym, $dims).base()
+#if str($softbits_lut).lower() == 'auto'
+self.$(id).gen_soft_dec_lut($precision)
+#else if str($softbits_lut) != 'None'
+self.$(id).set_softbits($softbits_lut, $precision)
+#end if
+</var_make>
+        <make></make>
+        <!--<callback></callback>-->
+
+        <!-- Required to 'trick' GRC into using this as a proper variable-->
+        <param>
+          <name>Ignore Me</name>
+          <key>value</key>
+          <value>"ok"</value>
+          <type>raw</type>
+          <hide>all</hide>
+        </param>
+
+	<param>
+          <name>Symbol Map</name>
+          <key>sym_map</key>
+          <value>[0, 1, 3, 2]</value>
+          <type>int_vector</type>
+	</param>
+	<param>
+          <name>Constellation Points</name>
+          <key>const_points</key>
+          <value>[-1-1j, -1+1j, 1+1j, 1-1j]</value>
+          <type>complex_vector</type>
+	</param>
+	<param>
+          <name>Rotational Symmetry</name>
+          <key>rot_sym</key>
+          <value>4</value>
+          <type>int</type>
+	</param>
+	<param>
+          <name>Dimensionality</name>
+          <key>dims</key>
+          <value>1</value>
+          <type>int</type>
+	</param>
+        <param>
+          <name>Soft bits precision</name>
+          <key>precision</key>
+          <value>8</value>
+          <type>int</type>
+          <hide>part</hide>
+        </param>
+        <param>
+          <name>Soft bits LUT</name>
+          <key>softbits_lut</key>
+          <value>None</value>
+          <type>raw</type>
+          <hide>#if str($softbits_lut) == 'None' then 'part' else 'none'#</hide>
+        </param>
+</block>
diff --git a/gr-digital/grc/digital_constellation_rect.xml b/gr-digital/grc/digital_constellation_rect.xml
new file mode 100644
index 0000000..e6acc14
--- /dev/null
+++ b/gr-digital/grc/digital_constellation_rect.xml
@@ -0,0 +1,87 @@
+<?xml version="1.0"?>
+<!--
+###################################################
+##Options Block:
+## options for window size,
+## and flow graph building.
+###################################################
+ -->
+<block>
+	<name>Constellation Rect. Object</name>
+	<key>variable_constellation_rect</key>
+        <category>Modulators</category>
+	<import>from gnuradio import digital</import>
+        <var_make>self.$(id) = $(id) = digital.constellation_rect($const_points, $sym_map, $rot_sym, $real_sect, $imag_sect, $w_real_sect, $w_imag_sect).base()
+#if str($softbits_lut) != 'None'
+self.$(id).set_softbits($softbits_lut, $precision)
+#end if
+</var_make>
+        <make></make>
+        <!--<callback>set_softbits($softbits_lut, $precision)</callback>-->
+
+        <!-- Required to 'trick' GRC into using this as a proper variable-->
+        <param>
+          <name>Ignore Me</name>
+          <key>value</key>
+          <value>"ok"</value>
+          <type>raw</type>
+          <hide>all</hide>
+        </param>
+
+	<param>
+          <name>Symbol Map</name>
+          <key>sym_map</key>
+          <value>[0, 1, 3, 2]</value>
+          <type>int_vector</type>
+	</param>
+	<param>
+          <name>Constellation Points</name>
+          <key>const_points</key>
+          <value>[-1-1j, -1+1j, 1+1j, 1-1j]</value>
+          <type>complex_vector</type>
+	</param>
+	<param>
+          <name>Rotational Symmetry</name>
+          <key>rot_sym</key>
+          <value>4</value>
+          <type>int</type>
+	</param>
+	<param>
+          <name>Real Sectors</name>
+          <key>real_sect</key>
+          <value>2</value>
+          <type>int</type>
+	</param>
+	<param>
+          <name>Imaginary Sectors</name>
+          <key>imag_sect</key>
+          <value>2</value>
+          <type>int</type>
+	</param>
+	<param>
+          <name>Width Real Sectors</name>
+          <key>w_real_sect</key>
+          <value>1</value>
+          <type>int</type>
+	</param>
+	<param>
+          <name>Width Imaginary Sectors</name>
+          <key>w_imag_sect</key>
+          <value>1</value>
+          <type>int</type>
+	</param>
+        <param>
+          <name>Soft bits precision</name>
+          <key>precision</key>
+          <value>8</value>
+          <type>int</type>
+          <hide>part</hide>
+        </param>
+        <param>
+          <name>Soft bits LUT</name>
+          <key>softbits_lut</key>
+          <value>None</value>
+          <type>raw</type>
+          <hide>#if str($softbits_lut) == 'None' then 'part' else 'none'#</hide>
+        </param>
+</block>
diff --git a/gr-digital/grc/digital_constellation_soft_decoder_cf.xml b/gr-digital/grc/digital_constellation_soft_decoder_cf.xml
new file mode 100644
index 0000000..6b0995a
--- /dev/null
+++ b/gr-digital/grc/digital_constellation_soft_decoder_cf.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0"?>
+<!--
+###################################################
+##Constellation Decoder, soft bits out
+###################################################
+ -->
+<block>
+	<name>Constellation Soft Decoder</name>
+	<key>digital_constellation_soft_decoder_cf</key>
+	<import>from gnuradio import digital</import>
+	<make>digital.constellation_soft_decoder_cf($constellation)</make>
+	<param>
+		<name>Constellation Object</name>
+		<key>constellation</key>
+		<type>raw</type>
+	</param>
+	<sink>
+		<name>in</name>
+		<type>complex</type>
+	</sink>
+	<source>
+		<name>out</name>
+		<type>float</type>
+	</source>
+</block>
diff --git a/gr-digital/include/gnuradio/digital/CMakeLists.txt b/gr-digital/include/gnuradio/digital/CMakeLists.txt
index 275da16..7515df7 100644
--- a/gr-digital/include/gnuradio/digital/CMakeLists.txt
+++ b/gr-digital/include/gnuradio/digital/CMakeLists.txt
@@ -1,4 +1,4 @@
-# Copyright 2011,2012 Free Software Foundation, Inc.
+# Copyright 2011-2013 Free Software Foundation, Inc.
 #
 # This file is part of GNU Radio
 #
@@ -84,6 +84,7 @@ install(FILES
     constellation.h
     constellation_decoder_cb.h
     constellation_receiver_cb.h
+    constellation_soft_decoder_cf.h
     correlate_access_code_bb.h
     correlate_access_code_tag_bb.h
     costas_loop_cc.h
diff --git a/gr-digital/include/gnuradio/digital/constellation_soft_decoder_cf.h b/gr-digital/include/gnuradio/digital/constellation_soft_decoder_cf.h
new file mode 100644
index 0000000..433be3a
--- /dev/null
+++ b/gr-digital/include/gnuradio/digital/constellation_soft_decoder_cf.h
@@ -0,0 +1,62 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2013 Free Software Foundation, Inc.
+ * 
+ * This file is part of GNU Radio
+ * 
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ * 
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef INCLUDED_DIGITAL_CONSTELLATION_SOFT_DECODER_CF_H
+#define INCLUDED_DIGITAL_CONSTELLATION_SOFT_DECODER_CF_H
+
+#include <gnuradio/digital/api.h>
+#include <gnuradio/digital/constellation.h>
+#include <gnuradio/sync_interpolator.h>
+
+namespace gr {
+  namespace digital {
+
+    /*!
+     * \brief Constellation Decoder
+     * \ingroup symbol_coding_blk
+     *
+     * \details
+     * Decode a constellation's points from a complex space to soft
+     * bits based on the map and soft decision lUT of the \p
+     * consetllation object.
+     */
+    class DIGITAL_API constellation_soft_decoder_cf
+      : virtual public sync_interpolator
+    {
+    public:
+      // gr::digital::constellation_soft_decoder_cf::sptr
+      typedef boost::shared_ptr<constellation_soft_decoder_cf> sptr;
+
+      /*!
+       * \brief Make constellation decoder block.
+       *
+       * \param constellation A constellation derived from class
+       * 'constellation'. Use base() method to get a shared pointer to
+       * this base class type.
+       */
+      static sptr make(constellation_sptr constellation);
+    };
+
+  } /* namespace digital */
+} /* namespace gr */
+
+#endif /* INCLUDED_DIGITAL_CONSTELLATION_SOFT_DECODER_CF_H */
diff --git a/gr-digital/lib/CMakeLists.txt b/gr-digital/lib/CMakeLists.txt
index a17c91a..dee5230 100644
--- a/gr-digital/lib/CMakeLists.txt
+++ b/gr-digital/lib/CMakeLists.txt
@@ -120,6 +120,7 @@ list(APPEND digital_sources
     constellation.cc
     constellation_decoder_cb_impl.cc
     constellation_receiver_cb_impl.cc
+    constellation_soft_decoder_cf_impl.cc
     correlate_access_code_bb_impl.cc
     correlate_access_code_tag_bb_impl.cc
     costas_loop_cc_impl.cc
diff --git a/gr-digital/lib/constellation_soft_decoder_cf_impl.cc b/gr-digital/lib/constellation_soft_decoder_cf_impl.cc
new file mode 100644
index 0000000..cd0a844
--- /dev/null
+++ b/gr-digital/lib/constellation_soft_decoder_cf_impl.cc
@@ -0,0 +1,78 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2013 Free Software Foundation, Inc.
+ * 
+ * This file is part of GNU Radio
+ * 
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ * 
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "constellation_soft_decoder_cf_impl.h"
+#include <gnuradio/io_signature.h>
+
+namespace gr {
+  namespace digital {
+
+    constellation_soft_decoder_cf::sptr
+    constellation_soft_decoder_cf::make(constellation_sptr constellation)
+    {
+      return gnuradio::get_initial_sptr
+	(new constellation_soft_decoder_cf_impl(constellation));
+    }
+
+    constellation_soft_decoder_cf_impl::
+    constellation_soft_decoder_cf_impl(constellation_sptr constellation)
+      : sync_interpolator("constellation_soft_decoder_cf",
+                          io_signature::make(1, 1, sizeof(gr_complex)),
+                          io_signature::make(1, 1, sizeof(float)),
+                          constellation->bits_per_symbol()),
+	d_constellation(constellation),
+	d_dim(constellation->dimensionality()),
+        d_bps(constellation->bits_per_symbol())
+    {
+    }
+
+    constellation_soft_decoder_cf_impl::~constellation_soft_decoder_cf_impl()
+    {
+    }
+
+    int
+    constellation_soft_decoder_cf_impl::work(int noutput_items,
+                                             gr_vector_const_void_star &input_items,
+                                             gr_vector_void_star &output_items)
+    {
+      gr_complex const *in = (const gr_complex*)input_items[0];
+      float *out = (float*)output_items[0];
+
+      std::vector<float> bits;
+
+      // FIXME: figure out how to manage d_dim
+      for(int i = 0; i < noutput_items/d_bps; i++) {
+	bits = d_constellation->soft_decision_maker(in[i]);
+        for(size_t j = 0; j < bits.size(); j++) {
+          out[d_bps*i+j] = bits[j];
+        }
+      }
+
+      return noutput_items;
+    }
+
+  } /* namespace digital */
+} /* namespace gr */
diff --git a/gr-digital/lib/constellation_soft_decoder_cf_impl.h b/gr-digital/lib/constellation_soft_decoder_cf_impl.h
new file mode 100644
index 0000000..8a1159b
--- /dev/null
+++ b/gr-digital/lib/constellation_soft_decoder_cf_impl.h
@@ -0,0 +1,50 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2013 Free Software Foundation, Inc.
+ * 
+ * This file is part of GNU Radio
+ * 
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ * 
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef INCLUDED_DIGITAL_CONSTELLATION_SOFT_DECODER_CF_IMPL_H
+#define INCLUDED_DIGITAL_CONSTELLATION_SOFT_DECODER_CF_IMPL_H
+
+#include <gnuradio/digital/constellation_soft_decoder_cf.h>
+
+namespace gr {
+  namespace digital {
+
+    class constellation_soft_decoder_cf_impl : public constellation_soft_decoder_cf
+    {
+    private:
+      constellation_sptr d_constellation;
+      unsigned int d_dim;
+      int d_bps;
+
+    public:
+      constellation_soft_decoder_cf_impl(constellation_sptr constellation);
+      ~constellation_soft_decoder_cf_impl();
+
+      int work(int noutput_items,
+               gr_vector_const_void_star &input_items,
+               gr_vector_void_star &output_items);
+    };
+
+  } /* namespace digital */
+} /* namespace gr */
+
+#endif /* INCLUDED_DIGITAL_CONSTELLATION_SOFT_DECODER_CF_IMPL_H */
diff --git a/gr-digital/python/digital/qa_constellation_soft_decoder_cf.py b/gr-digital/python/digital/qa_constellation_soft_decoder_cf.py
new file mode 100644
index 0000000..6cd7575
--- /dev/null
+++ b/gr-digital/python/digital/qa_constellation_soft_decoder_cf.py
@@ -0,0 +1,112 @@
+#!/usr/bin/env python
+#
+# Copyright 2013 Free Software Foundation, Inc.
+# 
+# This file is part of GNU Radio
+# 
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+# 
+
+from gnuradio import gr, gr_unittest, digital, blocks
+from math import sqrt
+
+class test_constellation_soft_decoder(gr_unittest.TestCase):
+
+    def setUp(self):
+        self.tb = gr.top_block()
+
+    def tearDown(self):
+        self.tb = None
+
+    def test_constellation_soft_decoder_cf_bpsk(self):
+        prec = 8
+  	src_data = (0.5 + 0.5j,  0.1 - 1.2j, -0.8 - 0.1j, -0.45 + 0.8j,
+                    0.8 + 1.0j, -0.5 + 0.1j,  0.1 - 1.2j, 1+1j)
+        lut = digital.soft_dec_table_generator(digital.sd_psk_2_0x0, prec)
+	expected_result = list()
+        for s in src_data:
+            expected_result += digital.calc_soft_dec_from_table(s, lut, prec, Es=2/sqrt(2))
+
+        cnst_pts, code = digital.psk_2_0x0()
+        cnst = digital.constellation_calcdist(cnst_pts, code, 2, 1)
+        cnst.set_soft_dec_lut(lut, int(prec))
+        src = blocks.vector_source_c(src_data)
+        op = digital.constellation_soft_decoder_cf(cnst.base())
+        dst = blocks.vector_sink_f()
+
+        self.tb.connect(src, op)
+        self.tb.connect(op, dst)
+        self.tb.run()               # run the graph and wait for it to finish
+
+        actual_result = dst.data()  # fetch the contents of the sink
+	#print "actual result", actual_result
+	#print "expected result", expected_result
+        self.assertFloatTuplesAlmostEqual(expected_result, actual_result, 4)
+
+    def test_constellation_soft_decoder_cf_qpsk(self):
+        prec = 8
+  	src_data = (0.5 + 0.5j,  0.1 - 1.2j, -0.8 - 0.1j, -0.45 + 0.8j,
+                    0.8 + 1.0j, -0.5 + 0.1j,  0.1 - 1.2j, 1+1j)
+        lut = digital.soft_dec_table_generator(digital.sd_psk_4_0x0_0_1, prec)
+	expected_result = list()
+        for s in src_data:
+            expected_result += digital.calc_soft_dec_from_table(s, lut, prec)
+
+        cnst_pts,code = digital.psk_4_0x0_0_1()
+        cnst = digital.constellation_calcdist(cnst_pts, code, 2, 1)
+        cnst.set_soft_dec_lut(lut, int(prec))
+        src = blocks.vector_source_c(src_data)
+        op = digital.constellation_soft_decoder_cf(cnst.base())
+        dst = blocks.vector_sink_f()
+
+        self.tb.connect(src, op)
+        self.tb.connect(op, dst)
+        self.tb.run()               # run the graph and wait for it to finish
+
+        actual_result = dst.data()  # fetch the contents of the sink
+	#print "actual result", actual_result
+	#print "expected result", expected_result
+        self.assertFloatTuplesAlmostEqual(expected_result, actual_result, 5)
+
+    def test_constellation_soft_decoder_cf_qam16(self):
+        prec = 8
+  	src_data = (0.5 + 0.5j,  0.1 - 1.2j, -0.8 - 0.1j, -0.45 + 0.8j,
+                    0.8 + 1.0j, -0.5 + 0.1j,  0.1 - 1.2j, 1+1j)
+        lut = digital.soft_dec_table_generator(digital.sd_qam_16_0x0_0_1_2_3, prec)
+	expected_result = list()
+        for s in src_data:
+            expected_result += digital.calc_soft_dec_from_table(s, lut, prec)
+
+        cnst_pts = digital.qam_16_0x0_0_1_2_3()
+        cnst = digital.constellation_calcdist(cnst_pts[0], cnst_pts[1], 2, 1)
+        cnst.set_soft_dec_lut(lut, int(prec))
+        src = blocks.vector_source_c(src_data)
+        op = digital.constellation_soft_decoder_cf(cnst.base())
+        dst = blocks.vector_sink_f()
+
+        self.tb.connect(src, op)
+        self.tb.connect(op, dst)
+        self.tb.run()               # run the graph and wait for it to finish
+
+        actual_result = dst.data()  # fetch the contents of the sink
+	#print "actual result", actual_result
+	#print "expected result", expected_result
+        self.assertFloatTuplesAlmostEqual(expected_result, actual_result, 5)
+
+
+if __name__ == '__main__':
+    gr_unittest.run(test_constellation_soft_decoder, "test_constellation_soft_decoder.xml")
+
diff --git a/gr-digital/swig/digital_swig.i b/gr-digital/swig/digital_swig.i
index fb0b97a..b16200c 100644
--- a/gr-digital/swig/digital_swig.i
+++ b/gr-digital/swig/digital_swig.i
@@ -51,6 +51,7 @@
 #include "gnuradio/digital/constellation.h"
 #include "gnuradio/digital/constellation_decoder_cb.h"
 #include "gnuradio/digital/constellation_receiver_cb.h"
+#include "gnuradio/digital/constellation_soft_decoder_cf.h"
 #include "gnuradio/digital/correlate_access_code_bb.h"
 #include "gnuradio/digital/correlate_access_code_tag_bb.h"
 #include "gnuradio/digital/costas_loop_cc.h"
@@ -120,6 +121,7 @@
 %include "gnuradio/digital/constellation.h"
 %include "gnuradio/digital/constellation_decoder_cb.h"
 %include "gnuradio/digital/constellation_receiver_cb.h"
+%include "gnuradio/digital/constellation_soft_decoder_cf.h"
 %include "gnuradio/digital/correlate_access_code_bb.h"
 %include "gnuradio/digital/correlate_access_code_tag_bb.h"
 %include "gnuradio/digital/costas_loop_cc.h"
@@ -184,6 +186,7 @@ GR_SWIG_BLOCK_MAGIC2(digital, clock_recovery_mm_ff);
 GR_SWIG_BLOCK_MAGIC2(digital, cma_equalizer_cc);
 GR_SWIG_BLOCK_MAGIC2(digital, constellation_decoder_cb);
 GR_SWIG_BLOCK_MAGIC2(digital, constellation_receiver_cb);
+GR_SWIG_BLOCK_MAGIC2(digital, constellation_soft_decoder_cf);
 GR_SWIG_BLOCK_MAGIC2(digital, correlate_access_code_bb);
 GR_SWIG_BLOCK_MAGIC2(digital, correlate_access_code_tag_bb);
 GR_SWIG_BLOCK_MAGIC2(digital, costas_loop_cc);
diff --git a/grc/blocks/variable_constellation.xml b/grc/blocks/variable_constellation.xml
deleted file mode 100644
index 7d23ede..0000000
--- a/grc/blocks/variable_constellation.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0"?>
-<!--
-###################################################
-##Options Block:
-## options for window size,
-## and flow graph building.
-###################################################
- -->
-<block>
-	<name>Constellation Object</name>
-	<key>variable_constellation</key>
-        <category>Modulators</category>
-	<import>from gnuradio import digital</import>
-        <var_make>self.$(id) = $(id) = digital.constellation_calcdist($const_points, $sym_map, $rot_sym, $dims).base()</var_make>
-        <make></make>
-        <!--<callback></callback>-->
-
-        <!-- Required to 'trick' GRC into using this as a proper variable-->
-        <param>
-          <name>Ignore Me</name>
-          <key>value</key>
-          <value>"ok"</value>
-          <type>raw</type>
-          <hide>all</hide>
-        </param>
-
-	<param>
-          <name>Symbol Map</name>
-          <key>sym_map</key>
-          <value>[0, 1, 3, 2]</value>
-          <type>int_vector</type>
-	</param>
-	<param>
-          <name>Constellation Points</name>
-          <key>const_points</key>
-          <value>[-1-1j, -1+1j, 1+1j, 1-1j]</value>
-          <type>complex_vector</type>
-	</param>
-	<param>
-          <name>Rotational Symmetry</name>
-          <key>rot_sym</key>
-          <value>4</value>
-          <type>int</type>
-	</param>
-	<param>
-          <name>Dimensionality</name>
-          <key>dims</key>
-          <value>1</value>
-          <type>int</type>
-	</param>
-</block>
diff --git a/grc/blocks/variable_constellation_rect.xml b/grc/blocks/variable_constellation_rect.xml
deleted file mode 100644
index 5c136ee..0000000
--- a/grc/blocks/variable_constellation_rect.xml
+++ /dev/null
@@ -1,69 +0,0 @@
-<?xml version="1.0"?>
-<!--
-###################################################
-##Options Block:
-## options for window size,
-## and flow graph building.
-###################################################
- -->
-<block>
-	<name>Constellation Rect. Object</name>
-	<key>variable_constellation_rect</key>
-        <category>Modulators</category>
-	<import>from gnuradio import digital</import>
-        <var_make>self.$(id) = $(id) = digital.constellation_rect($const_points, $sym_map, $rot_sym, $real_sect, $imag_sect, $w_real_sect, $w_imag_sect).base()</var_make>
-        <make></make>
-        <!--<callback></callback>-->
-
-        <!-- Required to 'trick' GRC into using this as a proper variable-->
-        <param>
-          <name>Ignore Me</name>
-          <key>value</key>
-          <value>"ok"</value>
-          <type>raw</type>
-          <hide>all</hide>
-        </param>
-
-	<param>
-          <name>Symbol Map</name>
-          <key>sym_map</key>
-          <value>[0, 1, 3, 2]</value>
-          <type>int_vector</type>
-	</param>
-	<param>
-          <name>Constellation Points</name>
-          <key>const_points</key>
-          <value>[-1-1j, -1+1j, 1+1j, 1-1j]</value>
-          <type>complex_vector</type>
-	</param>
-	<param>
-          <name>Rotational Symmetry</name>
-          <key>rot_sym</key>
-          <value>4</value>
-          <type>int</type>
-	</param>
-	<param>
-          <name>Real Sectors</name>
-          <key>real_sect</key>
-          <value>2</value>
-          <type>int</type>
-	</param>
-	<param>
-          <name>Imaginary Sectors</name>
-          <key>imag_sect</key>
-          <value>2</value>
-          <type>int</type>
-	</param>
-	<param>
-          <name>Width Real Sectors</name>
-          <key>w_real_sect</key>
-          <value>1</value>
-          <type>int</type>
-	</param>
-	<param>
-          <name>Width Imaginary Sectors</name>
-          <key>w_imag_sect</key>
-          <value>1</value>
-          <type>int</type>
-	</param>
-</block>
-- 
1.7.10.4

