From 729a30046691496680f5f3602ff355dece8f59e0 Mon Sep 17 00:00:00 2001
From: Martin Braun <martin.braun@ettus.com>
Date: Fri, 29 Apr 2016 22:14:02 -0700
Subject: [PATCH 30/46] digital: Fixes to packet_header_ofdm

- For unusual carrier allocations, the parser would report the wrong
  number of payload OFDM symbols => Fixed.
- Updated QA code to track this use case.
- Minor whitespace/indentation fixes
---
 .../include/gnuradio/digital/packet_header_ofdm.h  |  1 -
 gr-digital/lib/packet_header_default.cc            |  8 ++--
 gr-digital/lib/packet_header_ofdm.cc               | 55 +++++++++++-----------
 gr-digital/lib/packet_headergenerator_bb_impl.cc   |  3 +-
 .../python/digital/qa_packet_headerparser_b.py     |  7 ++-
 5 files changed, 37 insertions(+), 37 deletions(-)

diff --git a/gr-digital/include/gnuradio/digital/packet_header_ofdm.h b/gr-digital/include/gnuradio/digital/packet_header_ofdm.h
index 40255da..9703f2e 100644
--- a/gr-digital/include/gnuradio/digital/packet_header_ofdm.h
+++ b/gr-digital/include/gnuradio/digital/packet_header_ofdm.h
@@ -109,7 +109,6 @@ namespace gr {
      protected:
       pmt::pmt_t d_frame_len_tag_key; //!< Tag key of the additional frame length tag
       const std::vector<std::vector<int> > d_occupied_carriers; //!< Which carriers/symbols carry data
-      int d_syms_per_set; //!< Helper variable: Total number of elements in d_occupied_carriers
       int d_bits_per_payload_sym;
       std::vector<unsigned char> d_scramble_mask; //!< Bits are xor'd with this before tx'ing
     };
diff --git a/gr-digital/lib/packet_header_default.cc b/gr-digital/lib/packet_header_default.cc
index 12b8613..4d0c8df 100644
--- a/gr-digital/lib/packet_header_default.cc
+++ b/gr-digital/lib/packet_header_default.cc
@@ -62,12 +62,10 @@ namespace gr {
     }
 
     bool packet_header_default::header_formatter(
-	long packet_len,
+        long packet_len,
         unsigned char *out,
-
-	const std::vector<tag_t> &tags
-    )
-    {
+        const std::vector<tag_t> &tags
+    ) {
       packet_len &= 0x0FFF;
       d_crc_impl.reset();
       d_crc_impl.process_bytes((void const *) &packet_len, 2);
diff --git a/gr-digital/lib/packet_header_ofdm.cc b/gr-digital/lib/packet_header_ofdm.cc
index 4893b86..7a95586 100644
--- a/gr-digital/lib/packet_header_ofdm.cc
+++ b/gr-digital/lib/packet_header_ofdm.cc
@@ -74,14 +74,9 @@ namespace gr {
 	  bits_per_header_sym),
       d_frame_len_tag_key(pmt::string_to_symbol(frame_len_tag_key)),
       d_occupied_carriers(occupied_carriers),
-      d_syms_per_set(0),
       d_bits_per_payload_sym(bits_per_payload_sym),
       d_scramble_mask(d_header_len, 0)
     {
-      for (unsigned i = 0; i < d_occupied_carriers.size(); i++) {
-	d_syms_per_set += d_occupied_carriers[i].size();
-      }
-
       // Init scrambler mask
       if (scramble_header) {
 	// These are just random values which already have OK PAPR:
@@ -108,36 +103,40 @@ namespace gr {
     }
 
     bool packet_header_ofdm::header_parser(
-	const unsigned char *in,
-	std::vector<tag_t> &tags)
-    {
+        const unsigned char *in,
+        std::vector<tag_t> &tags
+    ) {
       std::vector<unsigned char> in_descrambled(d_header_len, 0);
       for (int i = 0; i < d_header_len; i++) {
-      	in_descrambled[i] = in[i] ^ d_scramble_mask[i];
+        in_descrambled[i] = in[i] ^ d_scramble_mask[i];
       }
       if (!packet_header_default::header_parser(&in_descrambled[0], tags)) {
-	return false;
+        return false;
       }
-      int packet_len = 0; // # of bytes in this frame
-      for (unsigned i = 0; i < tags.size(); i++) {
-	if (pmt::equal(tags[i].key, d_len_tag_key)) {
-	  // Convert bytes to complex symbols:
-	  packet_len = pmt::to_long(tags[i].value) * 8 / d_bits_per_payload_sym;
-	  if (pmt::to_long(tags[i].value) * 8 % d_bits_per_payload_sym) {
-	    packet_len++;
-	  }
-	  tags[i].value = pmt::from_long(packet_len);
-	  break;
-	}
+      int packet_len = 0; // # of complex symbols in this frame
+      for (size_t i = 0; i < tags.size(); i++) {
+        if (pmt::equal(tags[i].key, d_len_tag_key)) {
+          // Convert bytes to complex symbols:
+          packet_len = pmt::to_long(tags[i].value) * 8 / d_bits_per_payload_sym;
+          if (pmt::to_long(tags[i].value) * 8 % d_bits_per_payload_sym) {
+            packet_len++;
+          }
+          tags[i].value = pmt::from_long(packet_len);
+          break;
+        }
       }
 
-      // frame_len == # of OFDM symbols in this frame
-      int frame_len = packet_len / d_syms_per_set;
-      int k = 0;
-      int i = frame_len * d_syms_per_set;
-      while (i < packet_len) {
-	frame_len++;
-	i += d_occupied_carriers[k].size();
+      // To figure out how many payload OFDM symbols there are in this frame,
+      // we need to go through the carrier allocation and count the number of
+      // allocated carriers per OFDM symbol.
+      // frame_len == # of payload OFDM symbols in this frame
+      int frame_len = 0;
+      size_t k = 0; // position in the carrier allocation map
+      int symbols_accounted_for = 0;
+      while (symbols_accounted_for < packet_len) {
+        frame_len++;
+        symbols_accounted_for += d_occupied_carriers[k].size();
+        k = (k + 1) % d_occupied_carriers.size();
       }
       tag_t tag;
       tag.key = d_frame_len_tag_key;
diff --git a/gr-digital/lib/packet_headergenerator_bb_impl.cc b/gr-digital/lib/packet_headergenerator_bb_impl.cc
index 27f3b00..3dd2e04 100644
--- a/gr-digital/lib/packet_headergenerator_bb_impl.cc
+++ b/gr-digital/lib/packet_headergenerator_bb_impl.cc
@@ -68,7 +68,8 @@ namespace gr {
       set_relative_rate(d_formatter->header_len());
       set_tag_propagation_policy(TPP_DONT);
     }
-void 
+
+    void
     packet_headergenerator_bb_impl::set_header_formatter(packet_header_default::sptr header_formatter)
     {
       gr::thread::scoped_lock guard(d_setlock);
diff --git a/gr-digital/python/digital/qa_packet_headerparser_b.py b/gr-digital/python/digital/qa_packet_headerparser_b.py
index 1844991..fb4226d 100755
--- a/gr-digital/python/digital/qa_packet_headerparser_b.py
+++ b/gr-digital/python/digital/qa_packet_headerparser_b.py
@@ -97,6 +97,9 @@ class qa_packet_headerparser_b (gr_unittest.TestCase):
         """ Header 1: 193 bytes
         Header 2: 8 bytes
         2 bits per complex symbol, 32 carriers => 64 bits = 8 bytes per OFDM symbol
+                                    4 carriers =>  8 bits = 1 byte  per OFDM symbol
+                                    8 carriers => 16 bits = 2 bytes per OFDM symbol
+        Means we need 52 carriers to store the 193 bytes.
         """
         encoded_headers = (
             #   | Number of bytes                    | Packet number                      | CRC
@@ -107,7 +110,7 @@ class qa_packet_headerparser_b (gr_unittest.TestCase):
         frame_len_tagname = "frame_len"
         src = blocks.vector_source_b(encoded_headers)
         header_formatter = digital.packet_header_ofdm(
-                (range(32),), # 32 carriers are occupied (which doesn't matter here)
+                (range(32),range(4),range(8)), # 32/4/8 carriers are occupied (which doesn't matter here)
                 1,         # 1 OFDM symbol per header (= 32 bits)
                 packet_len_tagname,
                 frame_len_tagname,
@@ -127,7 +130,7 @@ class qa_packet_headerparser_b (gr_unittest.TestCase):
         msg1 = pmt.to_python(sink.get_message(0))
         msg2 = pmt.to_python(sink.get_message(1))
         # Multiply with 4 because unpacked bytes have only two bits
-        self.assertEqual(msg1, {'packet_len': 193*4, 'frame_len': 25, 'packet_num': 0})
+        self.assertEqual(msg1, {'packet_len': 193*4, 'frame_len': 52, 'packet_num': 0})
         self.assertEqual(msg2, {'packet_len': 8*4, 'frame_len': 1, 'packet_num': 1})
 
     def test_004_ofdm_scramble(self):
-- 
2.1.4

