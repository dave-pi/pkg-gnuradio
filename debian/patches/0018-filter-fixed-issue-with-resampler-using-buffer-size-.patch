From b3b8a1f4965f8283f2c3d22ae45b569b2fe6d713 Mon Sep 17 00:00:00 2001
From: Tom Rondeau <tom@trondeau.com>
Date: Wed, 18 Dec 2013 11:24:07 -0500
Subject: [PATCH 18/25] filter: fixed issue with resampler using buffer size
 information (always a mistake).

The intent was to ask the scheduler for the maximum amount of data. Now, it plays it safe by asking for just enough the next time. Performance tests show it works well.
---
 gr-filter/lib/pfb_arb_resampler_ccf_impl.cc     |    2 +-
 gr-filter/python/filter/qa_pfb_arb_resampler.py |   41 +++++++++++++++++++++--
 2 files changed, 40 insertions(+), 3 deletions(-)

diff --git a/gr-filter/lib/pfb_arb_resampler_ccf_impl.cc b/gr-filter/lib/pfb_arb_resampler_ccf_impl.cc
index 23950f3..86782fa 100644
--- a/gr-filter/lib/pfb_arb_resampler_ccf_impl.cc
+++ b/gr-filter/lib/pfb_arb_resampler_ccf_impl.cc
@@ -67,7 +67,7 @@ namespace gr {
       unsigned ninputs = ninput_items_required.size();
       if(noutput_items / relative_rate() < 1) {
         for(unsigned i = 0; i < ninputs; i++)
-          ninput_items_required[i] = max_output_buffer(i)-1;
+          ninput_items_required[i] = relative_rate() + history() - 1;
       }
       else {
         for(unsigned i = 0; i < ninputs; i++)
diff --git a/gr-filter/python/filter/qa_pfb_arb_resampler.py b/gr-filter/python/filter/qa_pfb_arb_resampler.py
index 674d508..bdc54b3 100755
--- a/gr-filter/python/filter/qa_pfb_arb_resampler.py
+++ b/gr-filter/python/filter/qa_pfb_arb_resampler.py
@@ -95,7 +95,7 @@ class test_pfb_arb_resampler(gr_unittest.TestCase):
         snk = blocks.vector_sink_c()
         
         self.tb.connect(signal, pfb, snk)
-        self.tb.run() 
+        self.tb.run()
 
         Ntest = 50
         L = len(snk.data())
@@ -103,7 +103,44 @@ class test_pfb_arb_resampler(gr_unittest.TestCase):
         # Get group delay and estimate of phase offset from the filter itself.
         delay = pfb.group_delay()
         phase = pfb.phase_offset(freq, fs)
-        
+
+        # Create a timeline offset by the filter's group delay
+        t = map(lambda x: float(x)/(fs*rrate), xrange(delay, L+delay))
+
+        # Data of the sinusoid at frequency freq with the delay and phase offset.
+        expected_data = map(lambda x: math.cos(2.*math.pi*freq*x+phase) + \
+                                1j*math.sin(2.*math.pi*freq*x+phase), t)
+
+        dst_data = snk.data()
+
+        self.assertComplexTuplesAlmostEqual(expected_data[-Ntest:], dst_data[-Ntest:], 2)
+
+    def test_ccf_001(self):
+        N = 50000        # number of samples to use
+        fs = 5000.0      # baseband sampling rate
+        rrate = 0.75     # resampling rate
+
+        nfilts = 32
+        taps = filter.firdes.low_pass_2(nfilts, nfilts*fs, fs/4, fs/10,
+                                        attenuation_dB=80,
+                                        window=filter.firdes.WIN_BLACKMAN_hARRIS)
+
+        freq = 211.123
+        data = sig_source_c(fs, freq, 1, N)
+        signal = blocks.vector_source_c(data)
+        pfb = filter.pfb_arb_resampler_ccf(rrate, taps, nfilts)
+        snk = blocks.vector_sink_c()
+
+        self.tb.connect(signal, pfb, snk)
+        self.tb.run()
+
+        Ntest = 50
+        L = len(snk.data())
+
+        # Get group delay and estimate of phase offset from the filter itself.
+        delay = pfb.group_delay()
+        phase = pfb.phase_offset(freq, fs)
+
         # Create a timeline offset by the filter's group delay
         t = map(lambda x: float(x)/(fs*rrate), xrange(delay, L+delay))
 
-- 
1.7.10.4

