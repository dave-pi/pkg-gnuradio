From 668835cb58ddee5431b9062ea1b5d04efa69c087 Mon Sep 17 00:00:00 2001
From: Michael Dickens <mlk@alum.mit.edu>
Date: Thu, 24 Apr 2014 09:57:49 -0400
Subject: [PATCH 24/33] whitespace only

---
 gnuradio-runtime/lib/thread/thread.cc |   22 +-
 gr-audio/lib/osx/osx_sink.cc          |  738 ++++++++++++++++-----------------
 2 files changed, 380 insertions(+), 380 deletions(-)

diff --git a/gnuradio-runtime/lib/thread/thread.cc b/gnuradio-runtime/lib/thread/thread.cc
index 5e5874e..8d1ef76 100644
--- a/gnuradio-runtime/lib/thread/thread.cc
+++ b/gnuradio-runtime/lib/thread/thread.cc
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2012-2013 Free Software Foundation, Inc.
+ * Copyright 2012-2014 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -72,7 +72,7 @@ namespace gr {
       DWORD_PTR ret = SetThreadAffinityMask(thread, dword_mask);
       if(ret == 0) {
         std::stringstream s;
-        s << "thread_bind_to_processor failed with error: " 
+        s << "thread_bind_to_processor failed with error: "
           << GetLastError() << std::endl;
         throw std::runtime_error(s.str());
       }
@@ -97,14 +97,14 @@ namespace gr {
       }
     }
 
-    int 
+    int
     thread_priority(gr_thread_t thread)
     {
       // Not implemented on Windows
       return -1;
     }
-    
-    int 
+
+    int
     set_thread_priority(gr_thread_t thread, int priority)
     {
       // Not implemented on Windows
@@ -164,14 +164,14 @@ namespace gr {
       // Not implemented on OSX
     }
 
-    int 
+    int
     thread_priority(gr_thread_t thread)
     {
       // Not implemented on OSX
       return -1;
     }
-    
-    int 
+
+    int
     set_thread_priority(gr_thread_t thread, int priority)
     {
       // Not implemented on OSX
@@ -262,7 +262,7 @@ namespace gr {
       }
     }
 
-    int 
+    int
     thread_priority(gr_thread_t thread)
     {
       sched_param param;
@@ -273,8 +273,8 @@ namespace gr {
       priority = param.sched_priority;
       return (ret==0)?priority:ret;
     }
-    
-    int 
+
+    int
     set_thread_priority(gr_thread_t thread, int priority)
     {
       int policy;
diff --git a/gr-audio/lib/osx/osx_sink.cc b/gr-audio/lib/osx/osx_sink.cc
index 2e1d32e..27329a2 100644
--- a/gr-audio/lib/osx/osx_sink.cc
+++ b/gr-audio/lib/osx/osx_sink.cc
@@ -57,18 +57,18 @@ namespace gr {
                       io_signature::make(0, 0, 0),
                       io_signature::make(0, 0, 0)),
         d_input_sample_rate(0.0), d_n_user_channels(0),
-	d_n_dev_channels(0), d_queue_sample_count(0),
-	d_buffer_sample_count(0), d_ok_to_block(ok_to_block),
-	d_do_reset(false), d_hardware_changed(false),
-	d_using_default_device(false), d_waiting_for_data(false),
-	d_desired_name(device_name.empty() ? default_device_name()
-		       : device_name),
-	d_output_au(0), d_output_ad_id(0)
+        d_n_dev_channels(0), d_queue_sample_count(0),
+        d_buffer_sample_count(0), d_ok_to_block(ok_to_block),
+        d_do_reset(false), d_hardware_changed(false),
+        d_using_default_device(false), d_waiting_for_data(false),
+        d_desired_name(device_name.empty() ? default_device_name()
+                       : device_name),
+        d_output_au(0), d_output_ad_id(0)
     {
       if(sample_rate <= 0) {
-	GR_LOG_ERROR(d_logger, boost::format
-		     ("Invalid Sample Rate: %d")
-		     % sample_rate);
+        GR_LOG_ERROR(d_logger, boost::format
+                     ("Invalid Sample Rate: %d")
+                     % sample_rate);
         throw std::invalid_argument("audio_osx_sink");
       }
       else {
@@ -94,51 +94,51 @@ namespace gr {
       std::vector < std::string > all_names;
 
       osx::find_audio_devices
-	(d_desired_name, false,
-	 &all_ad_ids, &all_names);
+        (d_desired_name, false,
+         &all_ad_ids, &all_names);
 
       // check number of device(s) returned
 
       if (d_desired_name.length() != 0) {
-	if (all_ad_ids.size() == 1) {
+        if (all_ad_ids.size() == 1) {
 
-	  // exactly 1 match was found; see if it was partial
+          // exactly 1 match was found; see if it was partial
 
-	  if (all_names[0].compare(d_desired_name) != 0) {
+          if (all_names[0].compare(d_desired_name) != 0) {
 
-	    // yes: log the full device name
-	    GR_LOG_INFO(d_logger, boost::format
-			("Using output audio device '%s'.")
-			% all_names[0]);
+            // yes: log the full device name
+            GR_LOG_INFO(d_logger, boost::format
+                        ("Using output audio device '%s'.")
+                        % all_names[0]);
 
-	  }
+          }
 
-	  // store info on this device
+          // store info on this device
 
-	  d_output_ad_id = all_ad_ids[0];
-	  d_selected_name = all_names[0];
+          d_output_ad_id = all_ad_ids[0];
+          d_selected_name = all_names[0];
 
-	} else {
+        } else {
 
-	  // either 0 or more than 1 device was found; get all output
-	  // device names, print those, and error out.
+          // either 0 or more than 1 device was found; get all output
+          // device names, print those, and error out.
 
-	  osx::find_audio_devices("", false, NULL, &all_names);
+          osx::find_audio_devices("", false, NULL, &all_names);
 
-	  std::string err_str("\n\nA unique output audio device name "
-			      "matching the string '");
-	  err_str += d_desired_name;
-	  err_str += "' was not found.\n\n";
-	  err_str += "The current known output audio device name";
-	  err_str += ((all_names.size() > 1) ? "s are" : " is");
-	  err_str += ":\n";
-	  for (UInt32 nn = 0; nn < all_names.size(); ++nn) {
-	    err_str += "    " + all_names[nn] + "\n";
-	  }
-	  GR_LOG_ERROR(d_logger, boost::format(err_str));
-	  throw std::runtime_error("audio_osx_sink::setup");
+          std::string err_str("\n\nA unique output audio device name "
+                              "matching the string '");
+          err_str += d_desired_name;
+          err_str += "' was not found.\n\n";
+          err_str += "The current known output audio device name";
+          err_str += ((all_names.size() > 1) ? "s are" : " is");
+          err_str += ":\n";
+          for (UInt32 nn = 0; nn < all_names.size(); ++nn) {
+            err_str += "    " + all_names[nn] + "\n";
+          }
+          GR_LOG_ERROR(d_logger, boost::format(err_str));
+          throw std::runtime_error("audio_osx_sink::setup");
 
-	}
+        }
       }
 
       // if no output audio device id was found, use the default
@@ -148,55 +148,55 @@ namespace gr {
 
         UInt32 size = sizeof(AudioDeviceID);
         AudioObjectPropertyAddress ao_address = {
-	  kAudioHardwarePropertyDefaultOutputDevice,
-	  kAudioObjectPropertyScopeGlobal,
-	  kAudioObjectPropertyElementMaster
+          kAudioHardwarePropertyDefaultOutputDevice,
+          kAudioObjectPropertyScopeGlobal,
+          kAudioObjectPropertyElementMaster
         };
 
         err = AudioObjectGetPropertyData
-	  (kAudioObjectSystemObject, &ao_address,
-	   0, NULL, &size, &d_output_ad_id);
-	check_error_and_throw
-	  (err, "Getting the default output audio device ID failed",
-	   "audio_osx_sink::setup");
+          (kAudioObjectSystemObject, &ao_address,
+           0, NULL, &size, &d_output_ad_id);
+        check_error_and_throw
+          (err, "Getting the default output audio device ID failed",
+           "audio_osx_sink::setup");
 
-	{
-	  // retrieve the device name; max name length is 64 characters.
+        {
+          // retrieve the device name; max name length is 64 characters.
 
-	  UInt32 prop_size = 65;
-	  char c_name_buf[prop_size];
-	  bzero((void*)c_name_buf, prop_size);
-	  --prop_size;
+          UInt32 prop_size = 65;
+          char c_name_buf[prop_size];
+          bzero((void*)c_name_buf, prop_size);
+          --prop_size;
 
-	  AudioObjectPropertyAddress ao_address = {
-	    kAudioDevicePropertyDeviceName,
-	    kAudioDevicePropertyScopeOutput, 0
-	  };
+          AudioObjectPropertyAddress ao_address = {
+            kAudioDevicePropertyDeviceName,
+            kAudioDevicePropertyScopeOutput, 0
+          };
 
-	  if ((err = AudioObjectGetPropertyData
-	       (d_output_ad_id, &ao_address, 0, NULL,
-		&prop_size, (void*)c_name_buf)) != noErr) {
+          if ((err = AudioObjectGetPropertyData
+               (d_output_ad_id, &ao_address, 0, NULL,
+                &prop_size, (void*)c_name_buf)) != noErr) {
 
-	    check_error(err, "Unable to retrieve output audio device name");
+            check_error(err, "Unable to retrieve output audio device name");
 
-	  } else {
+          } else {
 
-	    GR_LOG_INFO(d_logger, boost::format
-			 ("\n\nUsing output audio device '%s'.\n  ... "
-			  "which is the current default output audio"
-			  " device.\n  Changing the default output"
-			  " audio device in the System Preferences"
-			  " will \n  result in changing it here, too "
-			  "(with an internal reconfiguration).\n") %
-			std::string(c_name_buf));
+            GR_LOG_INFO(d_logger, boost::format
+                         ("\n\nUsing output audio device '%s'.\n  ... "
+                          "which is the current default output audio"
+                          " device.\n  Changing the default output"
+                          " audio device in the System Preferences"
+                          " will \n  result in changing it here, too "
+                          "(with an internal reconfiguration).\n") %
+                        std::string(c_name_buf));
 
-	  }
+          }
 
-	  d_selected_name = c_name_buf;
+          d_selected_name = c_name_buf;
 
-	}
+        }
 
-	d_using_default_device = true;
+        d_using_default_device = true;
 
       }
 
@@ -204,15 +204,15 @@ namespace gr {
       // output device
 
       osx::get_num_channels_for_audio_device_id
-	(d_output_ad_id, NULL, &d_n_dev_channels);
+        (d_output_ad_id, NULL, &d_n_dev_channels);
 
       // set the block input signature, if not already set
       // (d_n_user_channels is set in check_topology, which is called
       // before the flow-graph is running)
 
       if (d_n_user_channels == 0) {
-	set_input_signature(io_signature::make
-			     (1, d_n_dev_channels, sizeof(float)));
+        set_input_signature(io_signature::make
+                             (1, d_n_dev_channels, sizeof(float)));
       }
 
       // set the interim buffer size; to work with the GR scheduler,
@@ -220,12 +220,12 @@ namespace gr {
       // not very much.
 
       d_buffer_sample_count = (d_input_sample_rate < 50000.0 ?
-			       50000 : (UInt32)d_input_sample_rate);
+                               50000 : (UInt32)d_input_sample_rate);
 
 #if _OSX_AU_DEBUG_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink: max # samples = "
-		<< d_buffer_sample_count << std::endl;
+                << " : audio_osx_sink: max # samples = "
+                << d_buffer_sample_count << std::endl;
 #endif
 
       // create the default AudioUnit for output:
@@ -249,7 +249,7 @@ namespace gr {
       AudioComponent comp = AudioComponentFindNext(NULL, &desc);
       if(!comp) {
         GR_LOG_FATAL(d_logger, boost::format
-		     ("AudioComponentFindNext Failed"));
+                     ("AudioComponentFindNext Failed"));
         throw std::runtime_error("audio_osx_sink::setup");
       }
       err = AudioComponentInstanceNew(comp, &d_output_au);
@@ -261,42 +261,42 @@ namespace gr {
       Component comp = FindNextComponent(NULL, &desc);
       if(comp == NULL) {
         GR_LOG_FATAL(d_logger, boost::format
-		     ("FindNextComponent Failed"));
+                     ("FindNextComponent Failed"));
         throw std::runtime_error("audio_osx_sink::setup");
       }
       err = OpenAComponent(comp, &d_output_au);
       check_error_and_throw(err, "OpenAComponent Failed",
-			    "audio_osx_sink::setup");
+                            "audio_osx_sink::setup");
 
 #endif
 
       // set the selected device ID as the current output device
 
       err = AudioUnitSetProperty
-	(d_output_au, kAudioOutputUnitProperty_CurrentDevice,
-	 kAudioUnitScope_Global, 0,
-	 &d_output_ad_id, sizeof(d_output_ad_id));
+        (d_output_au, kAudioOutputUnitProperty_CurrentDevice,
+         kAudioUnitScope_Global, 0,
+         &d_output_ad_id, sizeof(d_output_ad_id));
       check_error_and_throw
-	(err, "Setting selected output device as current failed",
-	 "audio_osx_sink::setup");
+        (err, "Setting selected output device as current failed",
+         "audio_osx_sink::setup");
 
       // Set up a callback function to generate output to the output unit
 
       AURenderCallbackStruct au_callback = {
-	reinterpret_cast<AURenderCallback>
-	  (&osx_sink::au_output_callback),
+        reinterpret_cast<AURenderCallback>
+          (&osx_sink::au_output_callback),
         reinterpret_cast<void*>(this)
       };
       UInt32 prop_size = (UInt32)sizeof(au_callback);
 
       err = AudioUnitSetProperty
-	(d_output_au,
-	 kAudioUnitProperty_SetRenderCallback,
-	 kAudioUnitScope_Input, 0,
-	 &au_callback, prop_size);
+        (d_output_au,
+         kAudioUnitProperty_SetRenderCallback,
+         kAudioUnitScope_Input, 0,
+         &au_callback, prop_size);
       check_error_and_throw
-	(err, "Set Render Callback",
-	 "audio_osx_sink::setup");
+        (err, "Set Render Callback",
+         "audio_osx_sink::setup");
 
       // create the stream format for the output unit, so that it
       // handles any format conversions.  Set number of channels in
@@ -319,28 +319,28 @@ namespace gr {
       UInt32 render_quality = kRenderQuality_Max;
       prop_size = (UInt32)sizeof(render_quality);
       err = AudioUnitSetProperty
-	(d_output_au,
-	 kAudioUnitProperty_RenderQuality,
-	 kAudioUnitScope_Global, 0,
-	 &render_quality, prop_size);
+        (d_output_au,
+         kAudioUnitProperty_RenderQuality,
+         kAudioUnitScope_Global, 0,
+         &render_quality, prop_size);
       check_error(err, "Setting render quality failed");
 
       // clear the RunLoop (whatever that is); needed, for some
       // reason, before a listener will work.
 
       {
-	CFRunLoopRef the_run_loop = NULL;
-	AudioObjectPropertyAddress property = {
-	  kAudioHardwarePropertyRunLoop,
-	  kAudioObjectPropertyScopeGlobal,
-	  kAudioObjectPropertyElementMaster
-	};
-	prop_size = (UInt32)sizeof(the_run_loop);
-	err = AudioObjectSetPropertyData
-	  (kAudioObjectSystemObject, &property, 0, NULL,
-	   prop_size, &the_run_loop);
-	check_error(err, "Clearing RunLoop failed; "
-		    "Audio Output Device Listener might not work.");
+        CFRunLoopRef the_run_loop = NULL;
+        AudioObjectPropertyAddress property = {
+          kAudioHardwarePropertyRunLoop,
+          kAudioObjectPropertyScopeGlobal,
+          kAudioObjectPropertyElementMaster
+        };
+        prop_size = (UInt32)sizeof(the_run_loop);
+        err = AudioObjectSetPropertyData
+          (kAudioObjectSystemObject, &property, 0, NULL,
+           prop_size, &the_run_loop);
+        check_error(err, "Clearing RunLoop failed; "
+                    "Audio Output Device Listener might not work.");
       }
 
       // set up listeners
@@ -351,41 +351,41 @@ namespace gr {
 
       {
 
-	// set up a listener if hardware changes (at all)
+        // set up a listener if hardware changes (at all)
 
-	AudioObjectPropertyAddress property = {
-	  kAudioHardwarePropertyDevices,
-	  kAudioObjectPropertyScopeGlobal,
-	  kAudioObjectPropertyElementMaster
-	};
+        AudioObjectPropertyAddress property = {
+          kAudioHardwarePropertyDevices,
+          kAudioObjectPropertyScopeGlobal,
+          kAudioObjectPropertyElementMaster
+        };
 
-	err = AudioObjectAddPropertyListener
-	  (kAudioObjectSystemObject, &property,
-	   reinterpret_cast<AudioObjectPropertyListenerProc>
-	     (&osx_sink::hardware_listener),
-	   reinterpret_cast<void*>(this));
-	check_error(err, "Adding Audio Hardware Listener failed");
+        err = AudioObjectAddPropertyListener
+          (kAudioObjectSystemObject, &property,
+           reinterpret_cast<AudioObjectPropertyListenerProc>
+             (&osx_sink::hardware_listener),
+           reinterpret_cast<void*>(this));
+        check_error(err, "Adding Audio Hardware Listener failed");
       }
 
       if (d_using_default_device) {
 
-	// set up a listener for the default output device so that if
-	// the device changes, this routine will be called and we can
-	// internally handle this change (if/as necesary)
-
-	{
-	  AudioObjectPropertyAddress property = {
-	    kAudioHardwarePropertyDefaultOutputDevice,
-	    kAudioObjectPropertyScopeGlobal,
-	    kAudioObjectPropertyElementMaster
-	  };
-	  err = AudioObjectAddPropertyListener
-	    (kAudioObjectSystemObject, &property,
-	     reinterpret_cast<AudioObjectPropertyListenerProc>
-	       (&osx_sink::hardware_listener),
-	     reinterpret_cast<void*>(this));
-	  check_error(err, "Adding Default Output Audio Listener failed");
-	}
+        // set up a listener for the default output device so that if
+        // the device changes, this routine will be called and we can
+        // internally handle this change (if/as necesary)
+
+        {
+          AudioObjectPropertyAddress property = {
+            kAudioHardwarePropertyDefaultOutputDevice,
+            kAudioObjectPropertyScopeGlobal,
+            kAudioObjectPropertyElementMaster
+          };
+          err = AudioObjectAddPropertyListener
+            (kAudioObjectSystemObject, &property,
+             reinterpret_cast<AudioObjectPropertyListenerProc>
+               (&osx_sink::hardware_listener),
+             reinterpret_cast<void*>(this));
+          check_error(err, "Adding Default Output Audio Listener failed");
+        }
       }
 
 #else
@@ -393,20 +393,20 @@ namespace gr {
       // 10.5 and older
 
       err = AudioHardwareAddPropertyListener
-	(kAudioHardwarePropertyDevices,
-	 reinterpret_cast<AudioHardwarePropertyListenerProc>
-	   (&osx_sink::hardware_listener),
-	 reinterpret_cast<void*>(this));
+        (kAudioHardwarePropertyDevices,
+         reinterpret_cast<AudioHardwarePropertyListenerProc>
+           (&osx_sink::hardware_listener),
+         reinterpret_cast<void*>(this));
       check_error(err, "Adding Audio Hardware Listener failed");
 
       if (d_using_default_device) {
 
-	err = AudioHardwareAddPropertyListener
-	  (kAudioHardwarePropertyDefaultOutputDevice,
-	   reinterpret_cast<AudioHardwarePropertyListenerProc>
-	     (&osx_sink::default_listener),
-	   reinterpret_cast<void*>(this));
-	check_error(err, "Adding Default Output Audio Listener failed");
+        err = AudioHardwareAddPropertyListener
+          (kAudioHardwarePropertyDefaultOutputDevice,
+           reinterpret_cast<AudioHardwarePropertyListenerProc>
+             (&osx_sink::default_listener),
+           reinterpret_cast<void*>(this));
+        check_error(err, "Adding Default Output Audio Listener failed");
 
       }
 
@@ -416,16 +416,16 @@ namespace gr {
 
       err = AudioUnitInitialize(d_output_au);
       check_error_and_throw
-	(err, "AudioUnit Initialize Failed",
-	 "audio_osx_sink::setup");
+        (err, "AudioUnit Initialize Failed",
+         "audio_osx_sink::setup");
 
 
 #if _OSX_AU_DEBUG_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink Parameters:" << std::endl
-		<< "  Sample Rate is " << d_input_sample_rate << std::endl
-		<< "  Max # samples to store per channel is "
-		<< d_buffer_sample_count << std::endl;
+                << " : audio_osx_sink Parameters:" << std::endl
+                << "  Sample Rate is " << d_input_sample_rate << std::endl
+                << "  Max # samples to store per channel is "
+                << d_buffer_sample_count << std::endl;
 #endif
     }
 
@@ -433,8 +433,8 @@ namespace gr {
     {
 #if _OSX_AU_DEBUG_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::teardown: starting"
-		<< std::endl;
+                << " : audio_osx_sink::teardown: starting"
+                << std::endl;
 #endif
 
       OSStatus err = noErr;
@@ -444,22 +444,22 @@ namespace gr {
       stop();
 
       if (d_using_default_device) {
-	// remove the listener
-
-	OSStatus err = noErr;
-	AudioObjectPropertyAddress property = {
-	  kAudioHardwarePropertyDefaultOutputDevice,
-	  kAudioObjectPropertyScopeGlobal,
-	  kAudioObjectPropertyElementMaster
-	};
-	err = AudioObjectRemovePropertyListener
-	  (kAudioObjectSystemObject, &property,
-	   reinterpret_cast<AudioObjectPropertyListenerProc>
-	     (&osx_sink::hardware_listener),
-	   reinterpret_cast<void*>(this));
+        // remove the listener
+
+        OSStatus err = noErr;
+        AudioObjectPropertyAddress property = {
+          kAudioHardwarePropertyDefaultOutputDevice,
+          kAudioObjectPropertyScopeGlobal,
+          kAudioObjectPropertyElementMaster
+        };
+        err = AudioObjectRemovePropertyListener
+          (kAudioObjectSystemObject, &property,
+           reinterpret_cast<AudioObjectPropertyListenerProc>
+             (&osx_sink::hardware_listener),
+           reinterpret_cast<void*>(this));
 #if _OSX_AU_DEBUG_
-	check_error(err, "teardown: AudioObjectRemovePropertyListener "
-		    "hardware failed");
+        check_error(err, "teardown: AudioObjectRemovePropertyListener "
+                    "hardware failed");
 #endif
       }
 
@@ -495,15 +495,15 @@ namespace gr {
       // clear important variables; not # user channels
 
       d_n_dev_channels = d_n_buffer_channels =
-	d_queue_sample_count = d_buffer_sample_count = 0;
+        d_queue_sample_count = d_buffer_sample_count = 0;
       d_using_default_device = false;
       d_output_au = 0;
       d_output_ad_id = 0;
 
 #if _OSX_AU_DEBUG_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::teardown: finished"
-		<< std::endl;
+                << " : audio_osx_sink::teardown: finished"
+                << std::endl;
 #endif
     }
 
@@ -514,15 +514,15 @@ namespace gr {
 
       if (d_output_au) {
 
-	UInt32 prop_size = (UInt32)sizeof(UInt32);
-	OSStatus err = AudioUnitGetProperty
-	  (d_output_au,
-	   kAudioOutputUnitProperty_IsRunning,
-	   kAudioUnitScope_Global, 0,
-	   &au_running, &prop_size);
-	check_error_and_throw
-	  (err, "AudioUnitGetProperty IsRunning",
-	   "audio_osx_sink::is_running");
+        UInt32 prop_size = (UInt32)sizeof(UInt32);
+        OSStatus err = AudioUnitGetProperty
+          (d_output_au,
+           kAudioOutputUnitProperty_IsRunning,
+           kAudioUnitScope_Global, 0,
+           &au_running, &prop_size);
+        check_error_and_throw
+          (err, "AudioUnitGetProperty IsRunning",
+           "audio_osx_sink::is_running");
 
       }
 
@@ -536,9 +536,9 @@ namespace gr {
       if(noutputs != 0) {
 
         GR_LOG_FATAL(d_logger, boost::format
-		     ("check_topology(): number of output "
-		      "streams provided (%d) should be 0.")
-		     % noutputs);
+                     ("check_topology(): number of output "
+                      "streams provided (%d) should be 0.")
+                     % noutputs);
         throw std::runtime_error
           ("audio_osx_sink::check_topology");
 
@@ -548,10 +548,10 @@ namespace gr {
       if((ninputs < 1) | (ninputs > (int) d_n_dev_channels)) {
 
         GR_LOG_FATAL(d_logger, boost::format
-		     ("check_topology(): number of input "
-		      "streams provided (%d) should be in [1,%d] "
-		      "for the selected output audio device.")
-		     % ninputs % d_n_dev_channels);
+                     ("check_topology(): number of input "
+                      "streams provided (%d) should be in [1,%d] "
+                      "for the selected output audio device.")
+                     % ninputs % d_n_dev_channels);
         throw std::runtime_error("audio_osx_sink::check_topology");
 
       }
@@ -562,8 +562,8 @@ namespace gr {
 
 #if _OSX_AU_DEBUG_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::check_topology: "
-		<< "Actual # user input channels = "
+                << " : audio_osx_sink::check_topology: "
+                << "Actual # user input channels = "
                 << d_n_user_channels << std::endl;
 #endif
 
@@ -575,58 +575,58 @@ namespace gr {
     {
       if (d_buffers.size() == 0) {
 
-	// allocate the output circular buffer(s), one per user channel
+        // allocate the output circular buffer(s), one per user channel
 
-	d_buffers.resize(d_n_user_channels);
-	for(UInt32 nn = 0; nn < d_n_user_channels; ++nn) {
-	  d_buffers[nn] = new circular_buffer<float>
-	    (d_buffer_sample_count, false, false);
-	}
+        d_buffers.resize(d_n_user_channels);
+        for(UInt32 nn = 0; nn < d_n_user_channels; ++nn) {
+          d_buffers[nn] = new circular_buffer<float>
+            (d_buffer_sample_count, false, false);
+        }
       }
       else {
-	if(d_buffers.size() == d_n_user_channels) {
-	  if (force_reset) {
-	    for(UInt32 nn = 0; nn < d_buffers.size(); ++nn) {
-	      d_buffers[nn]->reset();
-	    }
-	  }
-	  return;
-	}
+        if(d_buffers.size() == d_n_user_channels) {
+          if (force_reset) {
+            for(UInt32 nn = 0; nn < d_buffers.size(); ++nn) {
+              d_buffers[nn]->reset();
+            }
+          }
+          return;
+        }
 
-	// reallocate the output circular buffer(s)
+        // reallocate the output circular buffer(s)
 
-	if (d_n_user_channels < d_buffers.size()) {
+        if (d_n_user_channels < d_buffers.size()) {
 
-	  // too many buffers; delete some
+          // too many buffers; delete some
 
-	  for (UInt32 nn = d_n_user_channels; nn < d_buffers.size(); ++nn) {
-	    delete d_buffers[nn];
-	    d_buffers[nn] = 0;
-	  }
-	  d_buffers.resize(d_n_user_channels);
+          for (UInt32 nn = d_n_user_channels; nn < d_buffers.size(); ++nn) {
+            delete d_buffers[nn];
+            d_buffers[nn] = 0;
+          }
+          d_buffers.resize(d_n_user_channels);
 
-	  // reset remaining buffers
+          // reset remaining buffers
 
-	  for(UInt32 nn = 0; nn < d_buffers.size(); ++nn) {
-	    d_buffers[nn]->reset();
-	  }
-	}
-	else {
+          for(UInt32 nn = 0; nn < d_buffers.size(); ++nn) {
+            d_buffers[nn]->reset();
+          }
+        }
+        else {
 
-	  // too few buffers; create some more
+          // too few buffers; create some more
 
-	  // reset old buffers first
+          // reset old buffers first
 
-	  for(UInt32 nn = 0; nn < d_buffers.size(); ++nn) {
-	    d_buffers[nn]->reset();
-	  }
+          for(UInt32 nn = 0; nn < d_buffers.size(); ++nn) {
+            d_buffers[nn]->reset();
+          }
 
-	  d_buffers.resize(d_n_user_channels);
-	  for (UInt32 nn = d_buffers.size(); nn < d_n_user_channels; ++nn) {
-	    d_buffers[nn] = new circular_buffer<float>
-	      (d_buffer_sample_count, false, false);
-	  }
-	}
+          d_buffers.resize(d_n_user_channels);
+          for (UInt32 nn = d_buffers.size(); nn < d_n_user_channels; ++nn) {
+            d_buffers[nn] = new circular_buffer<float>
+              (d_buffer_sample_count, false, false);
+          }
+        }
       }
 
       // reset the output audio unit for the correct number of channels
@@ -638,20 +638,20 @@ namespace gr {
       d_stream_format.mChannelsPerFrame = d_n_user_channels;
 
       err = AudioUnitSetProperty
-	(d_output_au,
-	 kAudioUnitProperty_StreamFormat,
-	 kAudioUnitScope_Input, 0,
-	 &d_stream_format, sizeof(d_stream_format));
+        (d_output_au,
+         kAudioUnitProperty_StreamFormat,
+         kAudioUnitScope_Input, 0,
+         &d_stream_format, sizeof(d_stream_format));
       check_error_and_throw
-	(err, "AudioUnitSetProperty StreamFormat",
-	 "audio_osx_sink::check_channels");
+        (err, "AudioUnitSetProperty StreamFormat",
+         "audio_osx_sink::check_channels");
 
       // initialize the AU for output, so that it is ready to be used
 
       err = AudioUnitInitialize(d_output_au);
       check_error_and_throw
-	(err, "AudioUnitInitialize",
-	 "audio_osx_sink::check_channels");
+        (err, "AudioUnitInitialize",
+         "audio_osx_sink::check_channels");
     }
 
     bool
@@ -660,28 +660,28 @@ namespace gr {
       if(!is_running() && d_output_au) {
 
 #if _OSX_AU_DEBUG_
-	std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::start: starting Output AudioUnit."
-		  << std::endl;
+        std::cerr << ((void*)(pthread_self()))
+                << " : audio_osx_sink::start: starting Output AudioUnit."
+                  << std::endl;
 #endif
 
-	// check channels, (re)allocate and reset buffers if/as necessary
+        // check channels, (re)allocate and reset buffers if/as necessary
 
-	check_channels(true);
+        check_channels(true);
 
-	// start the audio unit (should never fail)
+        // start the audio unit (should never fail)
 
         OSStatus err = AudioOutputUnitStart(d_output_au);
         check_error_and_throw
-	  (err, "AudioOutputUnitStart",
-	   "audio_osx_sink::start");
+          (err, "AudioOutputUnitStart",
+           "audio_osx_sink::start");
       }
 
 #if _OSX_AU_DEBUG_
       else {
-	std::cerr << ((void*)(pthread_self()))
-		  << " : audio_osx_sink::start: "
-		  << "already running." << std::endl;
+        std::cerr << ((void*)(pthread_self()))
+                  << " : audio_osx_sink::start: "
+                  << "already running." << std::endl;
       }
 #endif
 
@@ -694,46 +694,46 @@ namespace gr {
       if(is_running()) {
 
 #if _OSX_AU_DEBUG_
-	std::cerr << ((void*)(pthread_self()))
-		  << " : audio_osx_sink::stop: "
-		  << "stopping Output AudioUnit."
-		  << std::endl;
+        std::cerr << ((void*)(pthread_self()))
+                  << " : audio_osx_sink::stop: "
+                  << "stopping Output AudioUnit."
+                  << std::endl;
 #endif
 
-	// if waiting in ::work, signal to wake up
-	if (d_waiting_for_data) {
+        // if waiting in ::work, signal to wake up
+        if (d_waiting_for_data) {
 #if _OSX_AU_DEBUG_
-	  std::cerr << ((void*)(pthread_self()))
-		    << " : audio_osx_sink::stop: "
-		    << "signaling waiting condition" << std::endl;
+          std::cerr << ((void*)(pthread_self()))
+                    << " : audio_osx_sink::stop: "
+                    << "signaling waiting condition" << std::endl;
 #endif
-	  d_cond_data.notify_one();
-	}
+          d_cond_data.notify_one();
+        }
 
-	// stop the audio unit (should never fail)
+        // stop the audio unit (should never fail)
 
         OSStatus err = AudioOutputUnitStop(d_output_au);
         check_error_and_throw
-	  (err, "AudioOutputUnitStop",
-	   "audio_osx_sink::stop");
+          (err, "AudioOutputUnitStop",
+           "audio_osx_sink::stop");
 
-	// abort and reset all buffers
+        // abort and reset all buffers
 
         for(UInt32 nn = 0; nn < d_n_user_channels; ++nn) {
           d_buffers[nn]->abort();
           d_buffers[nn]->reset();
         }
 
-	// reset local knowledge of amount of data in queues
+        // reset local knowledge of amount of data in queues
 
-	d_queue_sample_count = 0;
+        d_queue_sample_count = 0;
 
       }
 #if _OSX_AU_DEBUG_
       else {
-	std::cerr << ((void*)(pthread_self()))
-		  << " : audio_osx_sink::stop: "
-		  << "already stopped." << std::endl;
+        std::cerr << ((void*)(pthread_self()))
+                  << " : audio_osx_sink::stop: "
+                  << "already stopped." << std::endl;
       }
 #endif
 
@@ -747,76 +747,76 @@ namespace gr {
     {
 #if _OSX_AU_DEBUG_RENDER_
       {
-	gr::thread::scoped_lock l(d_internal);
-	std::cerr << ((void*)(pthread_self()))
-		  << " : audio_osx_sink::work: "
-		  << "Starting: #OI = "
-		  << noutput_items << ", reset = "
-		  << (d_do_reset ? "true" : "false") << std::endl;
+        gr::thread::scoped_lock l(d_internal);
+        std::cerr << ((void*)(pthread_self()))
+                  << " : audio_osx_sink::work: "
+                  << "Starting: #OI = "
+                  << noutput_items << ", reset = "
+                  << (d_do_reset ? "true" : "false") << std::endl;
       }
 #endif
       if (d_do_reset) {
-	if (d_hardware_changed) {
-
-	  // see if the current AudioDeviceID is still available
-
-	  std::vector < AudioDeviceID > all_ad_ids;
-	  osx::find_audio_devices
-	    (d_desired_name, false,
-	     &all_ad_ids, NULL);
-	  bool found = false;
-	  for (UInt32 nn = 0; (nn < all_ad_ids.size()) && (!found);
-	       ++nn) {
-	    found = (all_ad_ids[nn] == d_output_ad_id);
-	  }
-	  if (!found) {
+        if (d_hardware_changed) {
+
+          // see if the current AudioDeviceID is still available
+
+          std::vector < AudioDeviceID > all_ad_ids;
+          osx::find_audio_devices
+            (d_desired_name, false,
+             &all_ad_ids, NULL);
+          bool found = false;
+          for (UInt32 nn = 0; (nn < all_ad_ids.size()) && (!found);
+               ++nn) {
+            found = (all_ad_ids[nn] == d_output_ad_id);
+          }
+          if (!found) {
 
-	    GR_LOG_FATAL(d_logger, boost::format
-			 ("The selected output audio device ('%s') "
-			  "is no longer available.\n")
-			 % d_selected_name);
-	    return(gr::block::WORK_DONE);
+            GR_LOG_FATAL(d_logger, boost::format
+                         ("The selected output audio device ('%s') "
+                          "is no longer available.\n")
+                         % d_selected_name);
+            return(gr::block::WORK_DONE);
 
-	  }
+          }
 
-	  d_do_reset = d_hardware_changed = false;
+          d_do_reset = d_hardware_changed = false;
 
-	}
-	else {
+        }
+        else {
 
 #if _OSX_AU_DEBUG_RENDER_
-	  {
-	    gr::thread::scoped_lock l(d_internal);
-	    std::cerr << ((void*)(pthread_self()))
-		      << " : audio_osx_sink::work: "
-		      << "doing reset." << std::endl;
-	  }
+          {
+            gr::thread::scoped_lock l(d_internal);
+            std::cerr << ((void*)(pthread_self()))
+                      << " : audio_osx_sink::work: "
+                      << "doing reset." << std::endl;
+          }
 #endif
 
-	  GR_LOG_WARN(d_logger, boost::format
-		      ("\n\nThe default output audio device has "
-		       "changed; resetting audio.\nThere may "
-		       "be a sound glitch while resetting.\n"));
+          GR_LOG_WARN(d_logger, boost::format
+                      ("\n\nThe default output audio device has "
+                       "changed; resetting audio.\nThere may "
+                       "be a sound glitch while resetting.\n"));
 
-	  // for any changes, just tear down the current
-	  // configuration, then set it up again using the user's
-	  // parameters to try to make selections.
+          // for any changes, just tear down the current
+          // configuration, then set it up again using the user's
+          // parameters to try to make selections.
 
-	  teardown();
+          teardown();
 
-	  gr::thread::scoped_lock l(d_internal);
+          gr::thread::scoped_lock l(d_internal);
 
-	  setup();
-	  start();
+          setup();
+          start();
 
 #if _OSX_AU_DEBUG_RENDER_
-	  std::cerr << ((void*)(pthread_self()))
-		    << " : audio_osx_sink: "
-		    << "returning 0 after reset."
-		    << std::endl;
+          std::cerr << ((void*)(pthread_self()))
+                    << " : audio_osx_sink: "
+                    << "returning 0 after reset."
+                    << std::endl;
 #endif
-	  return(0);
-	}
+          return(0);
+        }
       }
 
       gr::thread::scoped_lock l(d_internal);
@@ -841,8 +841,8 @@ namespace gr {
 
 #if _OSX_AU_DEBUG_RENDER_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::work: "
-		<< "qSC = " << d_queue_sample_count
+                << " : audio_osx_sink::work: "
+                << "qSC = " << d_queue_sample_count
                 << ", lMC = "<< l_max_count
                 << ", dBSC = " << d_buffer_sample_count
                 << ", #OI = " << noutput_items << std::endl;
@@ -858,36 +858,36 @@ namespace gr {
         if(d_ok_to_block == true) {
           // block until there is data to return, or on reset
           while(d_queue_sample_count > l_max_count) {
-	    // release control so-as to allow data to be retrieved;
-	    // block until there is data to return
+            // release control so-as to allow data to be retrieved;
+            // block until there is data to return
 #if _OSX_AU_DEBUG_RENDER_
-	    std::cerr << ((void*)(pthread_self()))
-		      << " : audio_osx_sink::work: "
-		      << "waiting." << std::endl;
+            std::cerr << ((void*)(pthread_self()))
+                      << " : audio_osx_sink::work: "
+                      << "waiting." << std::endl;
 #endif
-	    d_waiting_for_data = true;
-	    d_cond_data.wait(l);
-	    d_waiting_for_data = false;
+            d_waiting_for_data = true;
+            d_cond_data.wait(l);
+            d_waiting_for_data = false;
 #if _OSX_AU_DEBUG_RENDER_
-	    std::cerr << ((void*)(pthread_self()))
-		      << " : audio_osx_sink::work: "
-		      << "done waiting." << std::endl;
+            std::cerr << ((void*)(pthread_self()))
+                      << " : audio_osx_sink::work: "
+                      << "done waiting." << std::endl;
 #endif
-	    // the condition's 'notify' was called; acquire control to
-	    // keep thread safe
+            // the condition's 'notify' was called; acquire control to
+            // keep thread safe
 
-	    // if doing a reset, just return here; reset will pick
-	    // up the next time this method is called.
-	    if (d_do_reset) {
+            // if doing a reset, just return here; reset will pick
+            // up the next time this method is called.
+            if (d_do_reset) {
 #if _OSX_AU_DEBUG_RENDER_
-	      std::cerr << ((void*)(pthread_self()))
-			<< " : audio_osx_sink::work: "
-			<< "returning 0 for reset." << std::endl;
+              std::cerr << ((void*)(pthread_self()))
+                        << " : audio_osx_sink::work: "
+                        << "returning 0 for reset." << std::endl;
 #endif
-	      return(0);
-	    }
-	  }
-	}
+              return(0);
+            }
+          }
+        }
       }
 
       // not blocking and overflow is handled by the circular buffer,
@@ -904,14 +904,14 @@ namespace gr {
         int l_res = d_buffers[nn]->enqueue(inBuffer, noutput_items);
         if(l_res == -1) {
           res = -1;
-	}
+        }
       }
       while(nn < d_n_user_channels) {
         // for extra channels, copy the last input's data
         int l_res = d_buffers[nn++]->enqueue(inBuffer, noutput_items);
         if(l_res == -1) {
           res = -1;
-	}
+        }
       }
 
       // did overflow occur?
@@ -930,8 +930,8 @@ namespace gr {
 
 #if _OSX_AU_DEBUG_RENDER_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::work: "
-		<< "returning: #OI = "
+                << " : audio_osx_sink::work: "
+                << "returning: #OI = "
                 << noutput_items << ", qSC = "
                 << d_queue_sample_count << ", bSS = "
                 << d_buffer_sample_count << std::endl;
@@ -960,11 +960,11 @@ namespace gr {
 
 #if _OSX_AU_DEBUG_RENDER_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::au_output_callback: "
-		<< "starting: qSC = "
-		<< This->d_queue_sample_count
+                << " : audio_osx_sink::au_output_callback: "
+                << "starting: qSC = "
+                << This->d_queue_sample_count
                 << ", in#F = " << in_number_frames
-		<< ", in#C = " << This->d_n_user_channels << std::endl;
+                << ", in#C = " << This->d_n_user_channels << std::endl;
 #endif
 
       if(This->d_queue_sample_count < in_number_frames) {
@@ -994,7 +994,7 @@ namespace gr {
                       << "unexpectedly (should never happen): was "
                       << in_number_frames << " now "
                       << t_n_output_items<< std::endl;
-	    err = kAudioUnitErr_TooManyFramesToProcess;
+            err = kAudioUnitErr_TooManyFramesToProcess;
 
           }
         }
@@ -1006,19 +1006,19 @@ namespace gr {
 
       if (This->d_waiting_for_data) {
 #if _OSX_AU_DEBUG_RENDER_
-	std::cerr << ((void*)(pthread_self()))
-		  << " : audio_osx_sink::au_output_callback: "
-		  << "signaling waiting condition" << std::endl;
+        std::cerr << ((void*)(pthread_self()))
+                  << " : audio_osx_sink::au_output_callback: "
+                  << "signaling waiting condition" << std::endl;
 #endif
-	This->d_cond_data.notify_one();
+        This->d_cond_data.notify_one();
       }
 
 #if _OSX_AU_DEBUG_RENDER_
       std::cerr << ((void*)(pthread_self()))
-		<< " : audio_osx_sink::au_output_callback: "
-		<< "returning: qSC = "
+                << " : audio_osx_sink::au_output_callback: "
+                << "returning: qSC = "
                 << This->d_queue_sample_count
-		<< ", err = " << err << std::endl;
+                << ", err = " << err << std::endl;
 #endif
 
       return (err);
@@ -1043,7 +1043,7 @@ namespace gr {
 #endif
     {
       osx_sink* This = static_cast
-	<osx_sink*>(in_client_data);
+        <osx_sink*>(in_client_data);
       This->reset(true);
       return(noErr);
     }
@@ -1067,7 +1067,7 @@ namespace gr {
 #endif
     {
       osx_sink* This = reinterpret_cast
-	<osx_sink*>(in_client_data);
+        <osx_sink*>(in_client_data);
       This->reset(false);
       return(noErr);
     }
-- 
1.7.10.4

