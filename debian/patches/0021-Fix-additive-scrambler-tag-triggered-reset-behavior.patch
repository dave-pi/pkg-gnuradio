From e3ad82e6d93ea05d3b096673abf609f9e146f578 Mon Sep 17 00:00:00 2001
From: Brian Orr <brian.orr@gmail.com>
Date: Tue, 25 Apr 2017 10:06:54 -0700
Subject: [PATCH 21/72] Fix additive scrambler tag triggered reset behavior

Update the additive scrambler to reset its internal LFSR on the
correct byte when operating in tag triggered mode. The LFSR should be
reset at/before the byte associated with the reset tag instead of
after it. The existing reset behavior is still correct for byte count
triggered reset.

Fixes #1198
---
 gr-digital/lib/additive_scrambler_bb_impl.cc | 41 ++++++++++++++++++++--------
 1 file changed, 29 insertions(+), 12 deletions(-)

diff --git a/gr-digital/lib/additive_scrambler_bb_impl.cc b/gr-digital/lib/additive_scrambler_bb_impl.cc
index 58a2455aa5..d1112ee5f4 100644
--- a/gr-digital/lib/additive_scrambler_bb_impl.cc
+++ b/gr-digital/lib/additive_scrambler_bb_impl.cc
@@ -121,18 +121,35 @@ namespace gr {
       unsigned char *out = (unsigned char *)output_items[0];
       int reset_index = _get_next_reset_index(noutput_items);
 
-      for(int i = 0; i < noutput_items; i++) {
-	unsigned char scramble_byte = 0x00;
-	for (int k = 0; k < d_bits_per_byte; k++) {
-	  scramble_byte ^= (d_lfsr.next_bit() << k);
-	}
-	out[i] = in[i] ^ scramble_byte;
-	d_bytes++;
-	if (i == reset_index) {
-	  d_lfsr.reset();
-	  d_bytes = 0;
-	  reset_index = _get_next_reset_index(noutput_items, reset_index);
-	}
+      if (d_count >= 0) {
+        for(int i = 0; i < noutput_items; i++) {
+          unsigned char scramble_byte = 0x00;
+          for (int k = 0; k < d_bits_per_byte; k++) {
+            scramble_byte ^= (d_lfsr.next_bit() << k);
+          }
+          out[i] = in[i] ^ scramble_byte;
+          d_bytes++;
+          if (i == reset_index) {
+            d_lfsr.reset();
+            d_bytes = 0;
+            reset_index = _get_next_reset_index(noutput_items, reset_index);
+          }
+        }
+      } else {
+        for(int i = 0; i < noutput_items; i++) {
+          // Reset should occur at/before the item associated with the tag.
+          if (i == reset_index) {
+            d_lfsr.reset();
+            d_bytes = 0;
+            reset_index = _get_next_reset_index(noutput_items, reset_index);
+          }
+          unsigned char scramble_byte = 0x00;
+          for (int k = 0; k < d_bits_per_byte; k++) {
+            scramble_byte ^= (d_lfsr.next_bit() << k);
+          }
+          out[i] = in[i] ^ scramble_byte;
+          d_bytes++;
+        }
       }
 
       return noutput_items;
-- 
2.11.0

